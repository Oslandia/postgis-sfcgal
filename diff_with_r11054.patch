diff -Naur postgis-svn/configure.ac postgis-sfcgal/configure.ac
--- postgis-svn/configure.ac	2013-01-28 16:48:39.100627678 +0100
+++ postgis-sfcgal/configure.ac	2013-01-28 16:49:01.720628215 +0100
@@ -605,6 +605,85 @@
 
 
 dnl ===========================================================================
+dnl SFCGAL library support
+dnl ===========================================================================
+
+dnl ===========================================================================
+dnl
+dnl Selection of the geometric backend.
+dnl Geos is still needed for now.
+dnl
+dnl ===========================================================================
+
+AC_ARG_WITH([sfcgal], AC_HELP_STRING([--with-sfcgal], [add SFCGAL types]), 
+	[POSTGIS_SFCGAL=1], [POSTGIS_SFCGAL=0])
+
+AC_SUBST([POSTGIS_SFCGAL])
+
+dnl ===========================================================================
+dnl CGAL library
+dnl ===========================================================================
+
+AC_ARG_WITH([cgaldir], 
+	[AS_HELP_STRING([--with-cgaldir=PATH], [specify the CGAL installation directory])], 
+	[CGALDIR="$withval"], [CGALDIR="/usr/local"])
+
+if test -d "$CGALDIR"; then
+	AC_MSG_RESULT([Using CGAL directory: $CGALDIR])
+	dnl Add the include directory to SFCGAL_CPPFLAGS	
+	CGAL_CPPFLAGS="-I$CGALDIR/include"
+	# use RUNPATH
+	CGAL_LDFLAGS="-L$CGALDIR/lib -lCGAL -Wl,-rpath=$CGALDIR/lib,--enable-new-dtags"
+else
+	AC_MSG_ERROR([the --with-cgaldir directory "$CGALDIR" cannot be found]) 
+fi
+
+SFCGAL_CPPFLAGS="$CGAL_CPPFLAGS"
+SFCGAL_LDFLAGS="$CGAL_LDFLAGS"
+
+dnl ===========================================================================
+dnl SFCGAL library
+dnl ===========================================================================
+
+AC_ARG_WITH([sfcgaldir], 
+	[AS_HELP_STRING([--with-sfcgaldir=PATH], [specify the SFCGAL installation directory])], 
+	[SFCGALDIR="$withval"], [SFCGALDIR="/usr/local"])
+
+if test -d "$SFCGALDIR"; then
+	AC_MSG_RESULT([Using SFCGAL directory: $SFCGALDIR])
+	dnl Add the include directory to SFCGAL_CPPFLAGS	
+	SFCGAL_CPPFLAGS+=" -I$SFCGALDIR/include"
+	# Use RUNPATH
+	SFCGAL_LDFLAGS+=" -L$SFCGALDIR/lib -Wl,-rpath=$SFCGALDIR/lib,--enable-new-dtags"
+else
+	AC_MSG_ERROR([the --with-sfcgaldir directory "$SFCGALDIR" cannot be found]) 
+fi
+
+AC_SUBST([SFCGAL_CPPFLAGS])
+AC_SUBST([SFCGAL_LDFLAGS])
+
+dnl ===========================================================================
+dnl SFCGAL compilation mode
+dnl ===========================================================================
+
+AC_ARG_ENABLE([debug-sfcgal], AC_HELP_STRING([--enable-debug-sfcgal], [Use SFCGAL in debug mode]), 
+	[SFCGAL_MODE=Debug], [SFCGAL_MODE=Release]) 
+
+if test "x$SFCGAL_MODE" = "xDebug"; then
+   SFCGAL_CPPFLAGS+=" -frounding-math"
+   POSTGIS_SFCGAL_OBJS="lwgeom_sfcgal.o"
+   SFCGAL_LDFLAGS+=" -lSFCGALd"
+else
+   SFCGAL_CPPFLAGS+=" -frounding-math"
+   POSTGIS_SFCGAL_OBJS="lwgeom_sfcgal.o"
+   SFCGAL_LDFLAGS+=" -lSFCGAL"
+fi
+
+AC_SUBST(POSTGIS_SFCGAL_OBJS, $POSTGIS_SFCGAL_OBJS)
+AC_SUBST(SFCGAL_CPPFLAGS, $SFCGAL_CPPFLAGS)
+AC_SUBST(SFCGAL_LDFLAGS, $SFCGAL_LDFLAGS)
+
+dnl ===========================================================================
 dnl Detect gettext
 dnl ===========================================================================
 
@@ -1079,6 +1158,7 @@
 	RT_MAKEFILE_LIST="raster/Makefile"
 fi
 
+
 dnl ===========================================================================
 dnl See if we have the requirements for building the extensions, namely
 dnl PostgreSQL 9.1 or better and the xlstproc tool for generating the commends
@@ -1172,6 +1252,14 @@
 else
     AC_MSG_RESULT([  PostGIS Topology:     disabled])
 fi
+if test "x$POSTGIS_SFCGAL" = "x1"; then
+    AC_MSG_RESULT([  SFCGAL support:       yes])
+    AC_MSG_RESULT([  CGAL directory:       ${CGALDIR}])
+    AC_MSG_RESULT([  SFCGAL directory:     ${SFCGALDIR}])
+    AC_MSG_RESULT([  SFCGAL mode:          ${SFCGAL_MODE}])
+else
+    AC_MSG_RESULT([  SFCGAL support:       no])
+fi
 AC_MSG_RESULT()
 AC_MSG_RESULT([ -------- Documentation Generation -------- ])
 AC_MSG_RESULT([  xsltproc:             ${XSLTPROC}])
diff -Naur postgis-svn/liblwgeom/cunit/cu_sfcgal.c postgis-sfcgal/liblwgeom/cunit/cu_sfcgal.c
--- postgis-svn/liblwgeom/cunit/cu_sfcgal.c	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/liblwgeom/cunit/cu_sfcgal.c	2013-01-28 16:49:01.776628217 +0100
@@ -0,0 +1,100 @@
+/**********************************************************************
+ *
+ * PostGIS - Spatial Types for PostgreSQL
+ * http://postgis.refractions.net
+ *
+ *
+ * This is free software; you can redistribute and/or modify it under
+ * the terms of the GNU General Public Licence. See the COPYING file.
+ *
+ **********************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "CUnit/Basic.h"
+
+#include "cu_tester.h"
+#include "liblwgeom.h"
+
+extern LWGEOM* lwgeom_sfcgal_noop( const LWGEOM* geom_in );
+
+static void test_sfcgal_noop(void)
+{
+	int i;
+
+	char *ewkt[] =
+	{
+		"POINT(0 0.2)",
+		"LINESTRING(-1 -1,-1 2.5,2 2,2 -1)",
+		"TRIANGLE((0 0,-1 1,0 -1,0 0))",
+		"MULTIPOINT(0.9 0.9,0.9 0.9,0.9 0.9,0.9 0.9,0.9 0.9,0.9 0.9)",
+		"SRID=1;MULTILINESTRING((-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1))",
+		"SRID=1;MULTILINESTRING((-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1))",
+		"POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0))",
+		"SRID=4326;POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0))",
+		"SRID=4326;POLYGON((-1 -1 1,-1 2.5 1,2 2 2,2 -1 2,-1 -1 2),(0 0 1,0 1 1,1 1 1,1 0 2,0 0 2))",
+		"SRID=4326;POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5))",
+		"SRID=100000;POLYGON((-1 -1 3,-1 2.5 3,2 2 3,2 -1 3,-1 -1 3),(0 0 3,0 1 3,1 1 3,1 0 3,0 0 3),(-0.5 -0.5 3,-0.5 -0.4 3,-0.4 -0.4 3,-0.4 -0.5 3,-0.5 -0.5 3))",
+		"SRID=4326;MULTIPOLYGON(((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)),((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)))",
+		"SRID=4326;GEOMETRYCOLLECTION(POINT(0 1),POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0)),MULTIPOLYGON(((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5))))",
+		"POLYHEDRALSURFACE(((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)),((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)))",
+		"POLYHEDRALSURFACE(((-1 -1 1,-1 2.5 1,2 2 1,2 -1 1,-1 -1 1),(0 0 1,0 1 1,1 1 1,1 0 1,0 0 1),(-0.5 -0.5 1,-0.5 -0.4 1,-0.4 -0.4 1,-0.4 -0.5 1,-0.5 -0.5 1)),((-1 -1 1,-1 2.5 1,2 2 1,2 -1 1,-1 -1 1),(0 0 1,0 1 1,1 1 1,1 0 1,0 0 1),(-0.5 -0.5 1,-0.5 -0.4 1,-0.4 -0.4 1,-0.4 -0.5 1,-0.5 -0.5 1)))",
+		"TIN(((0 0,0 -1,-1 1,0 0)),((0 0,1 0,0 -1,0 0)))",
+	};
+
+	char *expected_ewkt[] =
+	{
+		"POINT(0 0.2)",
+		"LINESTRING(-1 -1,-1 2.5,2 2,2 -1)",
+		"TRIANGLE((0 0,-1 1,0 -1))",
+		"MULTIPOINT(0.9 0.9,0.9 0.9,0.9 0.9,0.9 0.9,0.9 0.9,0.9 0.9)",
+		"SRID=1;MULTILINESTRING((-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1))",
+		"SRID=1;MULTILINESTRING((-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1),(-1 -1,-1 2.5,2 2,2 -1))",
+		"POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0))",
+		"SRID=4326;POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0))",
+		"SRID=4326;POLYGON((-1 -1 1,-1 2.5 1,2 2 2,2 -1 2,-1 -1 2),(0 0 1,0 1 1,1 1 1,1 0 2,0 0 2))",
+		"SRID=4326;POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5))",
+		"SRID=100000;POLYGON((-1 -1 3,-1 2.5 3,2 2 3,2 -1 3,-1 -1 3),(0 0 3,0 1 3,1 1 3,1 0 3,0 0 3),(-0.5 -0.5 3,-0.5 -0.4 3,-0.4 -0.4 3,-0.4 -0.5 3,-0.5 -0.5 3))",
+		"SRID=4326;MULTIPOLYGON(((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)),((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)))",
+		"SRID=4326;GEOMETRYCOLLECTION(POINT(0 1),POLYGON((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0)),MULTIPOLYGON(((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5))))",
+		"POLYHEDRALSURFACE(((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)),((-1 -1,-1 2.5,2 2,2 -1,-1 -1),(0 0,0 1,1 1,1 0,0 0),(-0.5 -0.5,-0.5 -0.4,-0.4 -0.4,-0.4 -0.5,-0.5 -0.5)))",
+		"POLYHEDRALSURFACE(((-1 -1 1,-1 2.5 1,2 2 1,2 -1 1,-1 -1 1),(0 0 1,0 1 1,1 1 1,1 0 1,0 0 1),(-0.5 -0.5 1,-0.5 -0.4 1,-0.4 -0.4 1,-0.4 -0.5 1,-0.5 -0.5 1)),((-1 -1 1,-1 2.5 1,2 2 1,2 -1 1,-1 -1 1),(0 0 1,0 1 1,1 1 1,1 0 1,0 0 1),(-0.5 -0.5 1,-0.5 -0.4 1,-0.4 -0.4 1,-0.4 -0.5 1,-0.5 -0.5 1)))",
+		"TIN(((0 0,0 -1,-1 1)),((0 0,1 0,0 -1)))",
+	};
+
+	for ( i = 0; i < (sizeof ewkt/sizeof(char *)); i++ )
+	{
+		LWGEOM *geom_in, *geom_out;
+		char *in_ewkt;
+		char *out_ewkt;
+
+		in_ewkt = ewkt[i];
+		geom_in = lwgeom_from_wkt(in_ewkt, LW_PARSER_CHECK_NONE);
+		geom_out = lwgeom_sfcgal_noop(geom_in);
+		if ( ! geom_out ) {
+			fprintf(stderr, "\nNull return from lwgeom_sfcgal_noop with wkt:   %s\n", in_ewkt);
+			lwgeom_free(geom_in);
+			continue;
+		}
+		out_ewkt = lwgeom_to_ewkt(geom_out);
+		if (strcmp(expected_ewkt[i], out_ewkt))
+			fprintf(stderr, "\nExp:   %s\nObt:  %s\n", expected_ewkt[i], out_ewkt);
+		CU_ASSERT_STRING_EQUAL(expected_ewkt[i], out_ewkt);
+		lwfree(out_ewkt);
+		lwgeom_free(geom_out);
+		lwgeom_free(geom_in);
+	}
+}
+
+
+/*
+** Used by test harness to register the tests in this file.
+*/
+CU_TestInfo sfcgal_tests[] =
+{
+	PG_TEST(test_sfcgal_noop),
+	CU_TEST_INFO_NULL
+};
+CU_SuiteInfo sfcgal_suite = {"SFCGAL",  NULL,  NULL, sfcgal_tests};
+
diff -Naur postgis-svn/liblwgeom/cunit/cu_tester.c postgis-sfcgal/liblwgeom/cunit/cu_tester.c
--- postgis-svn/liblwgeom/cunit/cu_tester.c	2013-01-28 16:48:33.708627550 +0100
+++ postgis-sfcgal/liblwgeom/cunit/cu_tester.c	2013-01-28 16:49:01.776628217 +0100
@@ -37,6 +37,7 @@
 extern CU_SuiteInfo split_suite;
 extern CU_SuiteInfo geodetic_suite;
 extern CU_SuiteInfo geos_suite;
+extern CU_SuiteInfo sfcgal_suite;
 extern CU_SuiteInfo tree_suite;
 extern CU_SuiteInfo triangulate_suite;
 extern CU_SuiteInfo homogenize_suite;
@@ -74,6 +75,7 @@
 		split_suite,
 		geodetic_suite,
 		geos_suite,
+		sfcgal_suite,
 		tree_suite,
 		triangulate_suite,
 		stringbuffer_suite,
diff -Naur postgis-svn/liblwgeom/cunit/Makefile.in postgis-sfcgal/liblwgeom/cunit/Makefile.in
--- postgis-svn/liblwgeom/cunit/Makefile.in	2013-01-28 16:48:33.684627550 +0100
+++ postgis-sfcgal/liblwgeom/cunit/Makefile.in	2013-01-28 16:49:01.772628217 +0100
@@ -12,7 +12,7 @@
 
 CC=@CC@
 CFLAGS=@CFLAGS@ @WARNFLAGS@ @GEOS_CPPFLAGS@ @PROJ_CPPFLAGS@ 
-LDFLAGS = @GEOS_LDFLAGS@ -lgeos_c
+LDFLAGS = @GEOS_LDFLAGS@ -lgeos_c @SFCGAL_LDFLAGS@
 top_builddir = @top_builddir@
 SHELL = @SHELL@
 LIBTOOL = @LIBTOOL@
@@ -30,6 +30,7 @@
 	cu_ptarray.o \
 	cu_geodetic.o \
 	cu_geos.o \
+	cu_sfcgal.o \
 	cu_tree.o \
 	cu_measures.o \
 	cu_node.o \
diff -Naur postgis-svn/liblwgeom/lwgeom_sfcgal.cpp postgis-sfcgal/liblwgeom/lwgeom_sfcgal.cpp
--- postgis-svn/liblwgeom/lwgeom_sfcgal.cpp	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/liblwgeom/lwgeom_sfcgal.cpp	2013-01-28 16:49:01.780628217 +0100
@@ -0,0 +1,519 @@
+#include <stdexcept>
+
+#include <boost/format.hpp>
+
+#include <SFCGAL/Geometry.h>
+#include <SFCGAL/Point.h>
+#include <SFCGAL/LineString.h>
+#include <SFCGAL/Triangle.h>
+#include <SFCGAL/Polygon.h>
+#include <SFCGAL/GeometryCollection.h>
+#include <SFCGAL/MultiPoint.h>
+#include <SFCGAL/MultiLineString.h>
+#include <SFCGAL/MultiPolygon.h>
+#include <SFCGAL/PolyhedralSurface.h>
+#include <SFCGAL/TriangulatedSurface.h>
+#include <SFCGAL/Solid.h>
+
+extern "C"
+{
+#include "lwgeom_sfcgal.h"
+}
+
+// FIXMe debug
+using std::cout;
+using std::endl;
+
+int SFCGAL_type_to_lwgeom_type( SFCGAL::GeometryType type )
+{
+    switch ( type )
+    {
+    case SFCGAL::TYPE_POINT:
+	return POINTTYPE;
+    case SFCGAL::TYPE_LINESTRING:
+	return LINETYPE;
+    case SFCGAL::TYPE_POLYGON:
+	return POLYGONTYPE;
+    case SFCGAL::TYPE_MULTIPOINT:
+	return MULTIPOINTTYPE;
+    case SFCGAL::TYPE_MULTILINESTRING:
+	return MULTILINETYPE;
+    case SFCGAL::TYPE_MULTIPOLYGON:
+	return MULTIPOLYGONTYPE;
+    case SFCGAL::TYPE_MULTISOLID:
+	return COLLECTIONTYPE;
+    case SFCGAL::TYPE_GEOMETRYCOLLECTION:
+	return COLLECTIONTYPE;
+	//    case SFCGAL::TYPE_CIRCULARSTRING:
+	//	return CIRCSTRINGTYPE;
+	//    case SFCGAL::TYPE_COMPOUNDCURVE:
+	//	return COMPOUNDTYPE;
+	//    case SFCGAL::TYPE_CURVEPOLYGON:
+	//	return CURVEPOLYTYPE;
+	//    case SFCGAL::TYPE_MULTICURVE:
+	//	return MULTICURVETYPE;
+	//    case SFCGAL::TYPE_MULTISURFACE:
+	//	return MULTISURFACETYPE;
+	//    case SFCGAL::TYPE_CURVE:
+	// Unknown LWGEOM type
+	//	return 0;
+	//    case SFCGAL::TYPE_SURFACE:
+	// Unknown LWGEOM type
+	//	return 0;
+    case SFCGAL::TYPE_POLYHEDRALSURFACE:
+	return POLYHEDRALSURFACETYPE;
+    case SFCGAL::TYPE_TRIANGULATEDSURFACE:
+	return TINTYPE;
+    case SFCGAL::TYPE_TRIANGLE:
+	return TRIANGLETYPE;
+    };
+    return 0;
+}
+
+POINTARRAY* ptarray_from_SFCGAL( const SFCGAL::Geometry* geom, bool force3D = false)
+{
+    POINTARRAY* pa = 0;
+    POINT4D point;
+    bool want3d = force3D || geom->is3D();
+
+    switch ( geom->geometryTypeId() )
+    {
+    case SFCGAL::TYPE_POINT:
+	{
+	    const SFCGAL::Point* pt = static_cast<const SFCGAL::Point*>( geom );
+	    pa = ptarray_construct( want3d, 0, 1 );
+	    point.x = CGAL::to_double( pt->x() );
+	    point.y = CGAL::to_double( pt->y() );
+	    if ( geom->is3D() ) {
+		    point.z = CGAL::to_double( pt->z() );
+	    }
+	    else if ( force3D ) {
+		    point.z = 0.0;
+	    }	    
+	    point.m = 0.0;
+	    ptarray_set_point4d( pa, 0, &point );
+	    break;
+	}
+    case SFCGAL::TYPE_LINESTRING:
+	{
+	    const SFCGAL::LineString* ls = static_cast<const SFCGAL::LineString*>( geom );
+	    //	    pa = ptarray_construct( ls->is3D() ? 1 : 0, 0, ls->numPoints() );
+	    pa = ptarray_construct( want3d, 0, ls->numPoints() );
+
+	    for ( size_t i = 0; i < ls->numPoints(); i++ )
+	    {
+		const SFCGAL::Point* pt = &ls->pointN( i );
+		point.x = CGAL::to_double( pt->x() );
+		point.y = CGAL::to_double( pt->y() );
+		if ( geom->is3D() ) {
+			point.z = CGAL::to_double( pt->z() );
+		}
+		else if ( force3D ) {
+			point.z = 0.0;
+		}
+		point.m = 0.0;
+		ptarray_set_point4d( pa, i, &point );		
+	    }
+	    break;
+	}
+    case SFCGAL::TYPE_TRIANGLE:
+	{
+	    const SFCGAL::Triangle* tri = static_cast<const SFCGAL::Triangle*>( geom );
+	    pa = ptarray_construct( want3d, 0, 3 );
+
+	    for ( size_t i = 0; i < 3; i++ )
+	    {
+		const SFCGAL::Point* pt = &tri->vertex( i );
+		point.x = CGAL::to_double( pt->x() );
+		point.y = CGAL::to_double( pt->y() );
+		if ( geom->is3D() ) {
+			point.z = CGAL::to_double( pt->z() );
+		}
+		else if ( force3D ) {
+			point.z = 0.0;
+		}
+		point.m = 0.0;
+		ptarray_set_point4d( pa, i, &point );		
+	    }
+	    break;
+	}
+	// These other types should not be called directly ...
+    case SFCGAL::TYPE_POLYGON:
+    case SFCGAL::TYPE_MULTIPOINT:
+    case SFCGAL::TYPE_MULTILINESTRING:
+    case SFCGAL::TYPE_MULTIPOLYGON:
+    case SFCGAL::TYPE_GEOMETRYCOLLECTION:
+	//    case SFCGAL::TYPE_CIRCULARSTRING:
+	//    case SFCGAL::TYPE_COMPOUNDCURVE:
+	//    case SFCGAL::TYPE_CURVEPOLYGON:
+	//    case SFCGAL::TYPE_MULTICURVE:
+	//    case SFCGAL::TYPE_MULTISURFACE:
+	//    case SFCGAL::TYPE_CURVE:
+	//    case SFCGAL::TYPE_SURFACE:
+    case SFCGAL::TYPE_POLYHEDRALSURFACE:
+    case SFCGAL::TYPE_TRIANGULATEDSURFACE:
+    default:
+	throw std::runtime_error( "ptarray_from_SFCGAL: Unsupported SFCGAL geometry of type " + geom->geometryType() );
+	break;
+    }
+    return pa;
+}
+
+std::auto_ptr<SFCGAL::Geometry> ptarray_to_SFCGAL( const POINTARRAY* pa, int type )
+{
+    POINT3DZ point;
+
+    switch ( type )
+    {
+    case POINTTYPE:
+	{
+	    getPoint3dz_p( pa, 0, &point );
+	    bool is_3d = FLAGS_GET_Z( pa->flags ) != 0;
+	    if ( is_3d )
+		return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::Point( point.x, point.y, point.z ));
+	    else
+		return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::Point( point.x, point.y ));
+	}
+    case LINETYPE:
+	{
+	    SFCGAL::LineString* ret_geom = new SFCGAL::LineString;
+
+	    bool is_3d = FLAGS_GET_Z( pa->flags ) != 0;
+	    for ( size_t i = 0; i < pa->npoints; i++ )
+	    {
+		getPoint3dz_p( pa, i, &point );
+		if ( is_3d )
+		    ret_geom->addPoint( SFCGAL::Point( point.x, point.y, point.z ) );
+		else
+		    ret_geom->addPoint( SFCGAL::Point( point.x, point.y ) );
+	    }
+	    return std::auto_ptr<SFCGAL::Geometry>(ret_geom);
+	}
+    case TRIANGLETYPE:
+	{
+	    SFCGAL::Point p, q, r;
+
+	    bool is_3d = FLAGS_GET_Z( pa->flags ) != 0;
+	    getPoint3dz_p( pa, 0, &point );
+	    if ( is_3d )
+		p = SFCGAL::Point( point.x, point.y, point.z );
+	    else
+		p = SFCGAL::Point( point.x, point.y );
+	    getPoint3dz_p( pa, 1, &point );
+	    if ( is_3d )
+		q = SFCGAL::Point( point.x, point.y, point.z );
+	    else
+		q = SFCGAL::Point( point.x, point.y );
+	    getPoint3dz_p( pa, 2, &point );
+	    if ( is_3d )
+		r = SFCGAL::Point( point.x, point.y, point.z );
+	    else
+		r = SFCGAL::Point( point.x, point.y );
+
+	    return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::Triangle( p, q, r ));
+	}
+    }
+    return std::auto_ptr<SFCGAL::Geometry>(0);
+}
+
+LWGEOM* SFCGAL2LWGEOM( const SFCGAL::Geometry* geom, bool force3D, int SRID )
+{
+    bool want3d = force3D || geom->is3D();
+
+    switch ( geom->geometryTypeId() )
+    {
+    case SFCGAL::TYPE_POINT:
+	{
+	    if ( geom->isEmpty() )
+		return (LWGEOM*)lwpoint_construct_empty( SRID, want3d, 0 );
+	    POINTARRAY* pa = ptarray_from_SFCGAL( geom, force3D );
+	    return (LWGEOM*)lwpoint_construct( SRID, /* bbox */ NULL, pa );
+	}
+    case SFCGAL::TYPE_LINESTRING:
+	{
+	    if ( geom->isEmpty() )
+		return (LWGEOM*)lwline_construct_empty( SRID, want3d, 0 );
+	    POINTARRAY* pa = ptarray_from_SFCGAL( geom, force3D );
+	    return (LWGEOM*)lwline_construct( SRID, /* bbox */ NULL, pa );
+	}
+    case SFCGAL::TYPE_TRIANGLE:
+	{
+	    if ( geom->isEmpty() )
+		return (LWGEOM*)lwtriangle_construct_empty( SRID, want3d, 0 );
+	    POINTARRAY* pa = ptarray_from_SFCGAL( geom, force3D );
+	    return (LWGEOM*)lwtriangle_construct( SRID, /* bbox */ NULL, pa );
+	}
+    case SFCGAL::TYPE_POLYGON:
+	{
+	    if ( geom->isEmpty() )
+		return (LWGEOM*)lwpoly_construct_empty( SRID, want3d, 0 );
+
+	    const SFCGAL::Polygon* poly = static_cast<const SFCGAL::Polygon*>( geom );
+	    size_t n_interiors = poly->numInteriorRings();
+	    // allocate for all the rings (including the exterior one)
+	    POINTARRAY** pa = (POINTARRAY**) lwalloc( sizeof(POINTARRAY*) * (n_interiors + 1 ) );
+
+	    // write the exterior ring
+	    pa[0] = ptarray_from_SFCGAL( &poly->exteriorRing(), force3D );
+	    for ( size_t i = 0; i < n_interiors; i++ )
+	    {
+		    pa[ i+1 ] = ptarray_from_SFCGAL( &poly->interiorRingN( i ), force3D );
+	    }
+	    return (LWGEOM*)lwpoly_construct( SRID, NULL, n_interiors + 1, pa );
+	}
+    case SFCGAL::TYPE_MULTIPOINT:
+    case SFCGAL::TYPE_MULTILINESTRING:
+    case SFCGAL::TYPE_MULTIPOLYGON:
+    case SFCGAL::TYPE_MULTISOLID:
+    case SFCGAL::TYPE_GEOMETRYCOLLECTION:
+	{
+	    const SFCGAL::GeometryCollection* collection = static_cast<const SFCGAL::GeometryCollection*>( geom );
+	    size_t n_geoms = collection->numGeometries();
+	    LWGEOM** geoms = 0;
+	    if ( n_geoms )
+	    {
+		geoms = (LWGEOM**)lwalloc( sizeof(LWGEOM*) * n_geoms );
+		size_t j = 0;
+		for ( size_t i = 0; i < n_geoms; i++ )
+		{
+		    const SFCGAL::Geometry& g = collection->geometryN( i );
+		    if ( !g.isEmpty() )
+		    {
+			    // recurse call
+			    geoms[j++] = SFCGAL2LWGEOM( &g );
+		    }
+		}
+		n_geoms = j;
+		geoms = (LWGEOM**)lwrealloc( geoms, sizeof(LWGEOM*) * n_geoms );
+	    }
+	    return (LWGEOM*)lwcollection_construct( SFCGAL_type_to_lwgeom_type( geom->geometryTypeId() ),
+						    SRID,
+						    NULL,
+						    n_geoms,
+						    geoms );
+	}
+	//    case SFCGAL::TYPE_CIRCULARSTRING:
+	//    case SFCGAL::TYPE_COMPOUNDCURVE:
+	//    case SFCGAL::TYPE_CURVEPOLYGON:
+	//    case SFCGAL::TYPE_MULTICURVE:
+	//    case SFCGAL::TYPE_MULTISURFACE:
+	//    case SFCGAL::TYPE_CURVE:
+	//    case SFCGAL::TYPE_SURFACE:
+    case SFCGAL::TYPE_POLYHEDRALSURFACE:
+	{
+	    const SFCGAL::PolyhedralSurface* collection = static_cast<const SFCGAL::PolyhedralSurface*>( geom );
+	    size_t n_geoms = collection->numPolygons();
+	    LWGEOM** geoms = 0;
+	    if ( n_geoms )
+	    {
+		geoms = (LWGEOM**)lwalloc( sizeof(LWGEOM*) * n_geoms );
+		for ( size_t i = 0; i < n_geoms; i++ )
+		{
+		    const SFCGAL::Geometry& g = collection->polygonN( i );
+		    // recurse call
+		    geoms[i] = SFCGAL2LWGEOM( &g );
+		}
+	    }
+	    return (LWGEOM*)lwcollection_construct( POLYHEDRALSURFACETYPE,
+						    SRID,
+						    NULL,
+						    n_geoms,
+						    geoms );
+	}
+    case SFCGAL::TYPE_SOLID:
+	{
+		// a Solid is a closed PolyhedralSurface
+		const SFCGAL::Solid* solid = static_cast<const SFCGAL::Solid*>( geom );
+		// compute the number of polyhedral
+		size_t n_geoms = 0;
+		for ( size_t i = 0; i < solid->numShells(); ++i ) {
+			n_geoms += solid->shellN(i).numPolygons();
+		}
+		LWGEOM** geoms = 0;
+		if ( n_geoms )
+		{
+			geoms = (LWGEOM**)lwalloc( sizeof(LWGEOM*) * n_geoms );
+			size_t k = 0;
+			for ( size_t i = 0; i < solid->numShells(); i++ )
+			{
+				for ( size_t j = 0; j < solid->shellN(i).numPolygons(); ++j ) {
+					const SFCGAL::Geometry& g = solid->shellN(i).polygonN(j);
+					// recurse call
+					geoms[k] = SFCGAL2LWGEOM( &g, /* force3D = */ true );
+					++k;
+				}
+			}
+		}
+		LWGEOM* rgeom =  (LWGEOM*)lwcollection_construct( POLYHEDRALSURFACETYPE,
+								  SRID,
+								  NULL,
+								  n_geoms,
+								  geoms );
+		if ( n_geoms ) {
+			// set the 'Solid' flag before returning
+			FLAGS_SET_SOLID( rgeom->flags, 1 );
+		}
+		return rgeom;
+	}
+    case SFCGAL::TYPE_TRIANGULATEDSURFACE:
+	{
+	    const SFCGAL::TriangulatedSurface* collection = static_cast<const SFCGAL::TriangulatedSurface*>( geom );
+	    size_t n_geoms = collection->numTriangles();
+	    LWGEOM** geoms = 0;
+	    if ( n_geoms )
+	    {
+		geoms = (LWGEOM**)lwalloc( sizeof(LWGEOM*) * n_geoms );
+		for ( size_t i = 0; i < n_geoms; i++ )
+		{
+		    const SFCGAL::Geometry& g = collection->triangleN( i );
+		    // recurse call
+		    geoms[i] = SFCGAL2LWGEOM( &g );
+		}
+	    }
+	    return (LWGEOM*)lwcollection_construct( TINTYPE,
+						    SRID,
+						    NULL,
+						    n_geoms,
+						    geoms );
+	}
+    default:
+	throw std::runtime_error( "SFCGAL2LWGEOM: Unsupported SFCGAL geometry of type " + geom->geometryType() );
+	break;
+    }
+}
+
+std::auto_ptr<SFCGAL::Geometry> LWGEOM2SFCGAL( const LWGEOM* geom )
+{
+    SFCGAL::Geometry* ret_geom = 0;
+    POINT3DZ point;
+
+    switch ( geom->type )
+    {
+    case POINTTYPE:
+	{
+	    const LWPOINT* lwp = (const LWPOINT*) geom;
+	    if ( lwgeom_is_empty( geom ) )
+		return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::Point());
+
+	    return ptarray_to_SFCGAL( lwp->point, POINTTYPE );
+	}
+	break;
+    case LINETYPE:
+	{
+	    const LWLINE* line = (const LWLINE*) geom;
+	    if ( lwgeom_is_empty( geom ) )
+		return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::LineString());
+
+	    return ptarray_to_SFCGAL( line->points, LINETYPE );
+	}
+	break;
+    case TRIANGLETYPE:
+	{
+	    const LWTRIANGLE* tri = (const LWTRIANGLE*) geom;
+	    if ( lwgeom_is_empty( geom ) )
+		return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::Triangle());
+
+	    return ptarray_to_SFCGAL( tri->points, TRIANGLETYPE );
+	}
+	break;
+    case POLYGONTYPE:
+	{
+	    const LWPOLY* poly = (const LWPOLY*) geom;
+	    if ( lwgeom_is_empty( geom ) )
+		return std::auto_ptr<SFCGAL::Geometry>(new SFCGAL::Polygon());
+
+	    size_t n_rings = poly->nrings - 1;
+	    
+	    std::auto_ptr<SFCGAL::Geometry> ext_ring(ptarray_to_SFCGAL( poly->rings[0], LINETYPE ));
+	    SFCGAL::Polygon* ret_poly = new SFCGAL::Polygon( *static_cast<SFCGAL::LineString*>(ext_ring.get()) );
+
+	    for ( size_t i = 0; i < n_rings; i++ )
+	    {
+		std::auto_ptr<SFCGAL::Geometry> ring(ptarray_to_SFCGAL( poly->rings[ i + 1 ], LINETYPE ));
+		// takes ownership
+		ret_poly->addRing( static_cast<SFCGAL::LineString*>(ring.release()) );
+	    }
+	    return std::auto_ptr<SFCGAL::Geometry>(ret_poly);
+	}
+	break;
+    case MULTIPOINTTYPE:
+    case MULTILINETYPE:
+    case MULTIPOLYGONTYPE:
+    case COLLECTIONTYPE:
+	{
+	    if ( geom->type == MULTIPOINTTYPE )
+		ret_geom = new SFCGAL::MultiPoint();
+	    else if ( geom->type == MULTILINETYPE )
+		ret_geom = new SFCGAL::MultiLineString();
+	    else if ( geom->type == MULTIPOLYGONTYPE )
+		ret_geom = new SFCGAL::MultiPolygon();
+	    else
+		ret_geom = new SFCGAL::GeometryCollection();
+	    
+	    const LWCOLLECTION* lwc = (const LWCOLLECTION*)geom;
+	    for ( size_t i = 0; i < lwc->ngeoms; i++ )
+	    {
+		// recurse call
+		std::auto_ptr<SFCGAL::Geometry> g(LWGEOM2SFCGAL( lwc->geoms[i] ));
+		// takes ownership of the pointer
+		static_cast<SFCGAL::GeometryCollection*>(ret_geom)->addGeometry( g.release() );
+	    }
+	    return std::auto_ptr<SFCGAL::Geometry>(ret_geom);
+	}
+	break;
+    case POLYHEDRALSURFACETYPE:
+	{
+	    const LWPSURFACE* lwp = (const LWPSURFACE*)geom;
+	    ret_geom = new SFCGAL::PolyhedralSurface();
+
+	    for ( size_t i = 0; i < lwp->ngeoms; i++ )
+	    {
+		// recurse call
+		std::auto_ptr<SFCGAL::Geometry> g(LWGEOM2SFCGAL( (const LWGEOM*)lwp->geoms[i] ));
+		BOOST_ASSERT( g->geometryTypeId() == SFCGAL::TYPE_POLYGON );
+		// add the obtained polygon to the surface
+		// (pass ownership )
+		static_cast<SFCGAL::PolyhedralSurface*>(ret_geom)->addPolygon( static_cast<SFCGAL::Polygon*>(g.release()) );
+	    }
+	    if ( FLAGS_GET_SOLID( lwp->flags ) ) {
+		    // return a Solid
+		    // FIXME: we treat polyhedral surface as the only exterior shell, since we do not have
+		    // any way to distinguish exterior from interior shells ...
+		    return std::auto_ptr<SFCGAL::Geometry>( new SFCGAL::Solid( ret_geom->as<SFCGAL::PolyhedralSurface>() ) );
+	    }
+	    const SFCGAL::PolyhedralSurface& p = static_cast<const SFCGAL::PolyhedralSurface&>(*ret_geom);
+	    return std::auto_ptr<SFCGAL::Geometry>(ret_geom);
+	}
+    case TINTYPE:
+	{
+	    const LWTIN* lwp = (const LWTIN*)geom;
+	    ret_geom = new SFCGAL::TriangulatedSurface();
+
+	    for ( size_t i = 0; i < lwp->ngeoms; i++ )
+	    {
+		// recurse call
+		std::auto_ptr<SFCGAL::Geometry> g(LWGEOM2SFCGAL( (const LWGEOM*)lwp->geoms[i] ));
+		BOOST_ASSERT( g->geometryTypeId() == SFCGAL::TYPE_TRIANGLE );
+		// add the obtained polygon to the surface
+		static_cast<SFCGAL::TriangulatedSurface*>(ret_geom)->addTriangle( *static_cast<SFCGAL::Triangle*>(g.get()) );
+	    }
+	    return std::auto_ptr<SFCGAL::Geometry>(ret_geom);
+	}
+    default:
+	throw std::runtime_error( (boost::format( "Unsupported LWGEOM type %1%" ) % geom->type ).str() );
+    }
+    return std::auto_ptr<SFCGAL::Geometry>(ret_geom);
+}
+
+LWGEOM* lwgeom_sfcgal_noop( const LWGEOM* geom_in )
+{
+    std::auto_ptr<SFCGAL::Geometry> converted = LWGEOM2SFCGAL( geom_in );
+
+    // Noop
+
+    LWGEOM* geom_out = SFCGAL2LWGEOM( converted.get() );
+
+    // copy SRID (SFCGAL does not store the SRID)
+    geom_out->srid = geom_in->srid;
+    return geom_out;
+}
diff -Naur postgis-svn/liblwgeom/lwgeom_sfcgal.h postgis-sfcgal/liblwgeom/lwgeom_sfcgal.h
--- postgis-svn/liblwgeom/lwgeom_sfcgal.h	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/liblwgeom/lwgeom_sfcgal.h	2013-01-28 16:49:01.780628217 +0100
@@ -0,0 +1,20 @@
+#ifndef LWGEOM_SFCGAL_H
+#define LWGEOM_SFCGAL_H
+
+#include <SFCGAL/Geometry.h>
+// auto_ptr
+#include <memory>
+
+extern "C"
+{
+
+#include "liblwgeom.h"
+
+LWGEOM* lwgeom_sfcgal_noop( const LWGEOM* geom_in );
+
+};
+
+extern "C++" LWGEOM*                         SFCGAL2LWGEOM( const SFCGAL::Geometry* geom, bool force3D = false, int SRID = SRID_UNKNOWN );
+extern "C++" std::auto_ptr<SFCGAL::Geometry> LWGEOM2SFCGAL( const LWGEOM* geom );
+
+#endif
diff -Naur postgis-svn/liblwgeom/Makefile.in postgis-sfcgal/liblwgeom/Makefile.in
--- postgis-svn/liblwgeom/Makefile.in	2013-01-28 16:48:34.272627564 +0100
+++ postgis-sfcgal/liblwgeom/Makefile.in	2013-01-28 16:49:01.772628217 +0100
@@ -12,6 +12,7 @@
 
 CC = @CC@
 CFLAGS = @CFLAGS@ @PICFLAGS@ @WARNFLAGS@ @GEOS_CPPFLAGS@ @PROJ_CPPFLAGS@
+CXXFLAGS = @CFLAGS@ @PICFLAGS@ @GEOS_CPPFLAGS@ @PROJ_CPPFLAGS@
 LDFLAGS = @LDFLAGS@ @GEOS_LDFLAGS@ -lgeos_c @PROJ_LDFLAGS@ -lproj
 NUMERICFLAGS = @NUMERICFLAGS@
 top_builddir = @top_builddir@
@@ -91,9 +92,17 @@
 NM_OBJS = \
 	lwspheroid.o 
 
+SFCGAL_OBJS = lwgeom_sfcgal.o
+
 LT_SA_OBJS = $(SA_OBJS:.o=.lo)
 LT_NM_OBJS = $(NM_OBJS:.o=.lo)
-LT_OBJS = $(LT_SA_OBJS) $(LT_NM_OBJS)
+LT_OBJS = $(LT_SA_OBJS) $(LT_NM_OBJS) $(LT_CPP_OBJS)
+
+ifeq (@POSTGIS_SFCGAL@,1)
+CXXFLAGS += @SFCGAL_CPPFLAGS@
+LDFLAGS += SFCGAL_LDFLAGS@
+LT_OBJS += $(SFCGAL_OBJS:.o=.lo)
+endif
 
 SA_HEADERS = \
 	liblwgeom.h \
@@ -153,12 +162,14 @@
 $(LT_NM_OBJS): %.lo: %.c
 	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(NUMERICFLAGS) -c -o $@ $<
 
+$(LT_CPP_OBJS): %.lo: %.cpp
+	$(LIBTOOL) --mode=compile $(CXX) $(CXXFLAGS) $(NUMERICFLAGS) -c -o $@ $<
+
 # Manually generate WKT parser from Flex/Bison inputs
 # Bison 2.5, Flex 2.5.35
 parser:
 	$(YACC) -o'lwin_wkt_parse.c' -d lwin_wkt_parse.y
 	$(LEX) -i lwin_wkt_lex.l
-	
 #	$(YACC) --debug --verbose -o'$@' -d $<
 #	$(YACC) -o'$@' -d $^
 #	$(LEX) -i $<
diff -Naur postgis-svn/loader/Makefile.in postgis-sfcgal/loader/Makefile.in
--- postgis-svn/loader/Makefile.in	2013-01-28 16:48:36.092627606 +0100
+++ postgis-sfcgal/loader/Makefile.in	2013-01-28 16:49:01.788628217 +0100
@@ -28,6 +28,10 @@
 INSTALL = $(SHELL) ../install-sh
 LIBTOOL = @LIBTOOL@
 
+ifeq (@POSTGIS_SFCGAL@,1)
+SFCGAL_LDFLAGS = @SFCGAL_LDFLAGS@
+endif
+
 # Filenames with extension as determined by the OS
 PGSQL2SHP-CLI=pgsql2shp@EXESUFFIX@
 SHP2PGSQL-CLI=shp2pgsql@EXESUFFIX@
@@ -97,11 +101,11 @@
 
 $(PGSQL2SHP-CLI): $(SHPLIB_OBJS) pgsql2shp-core.o pgsql2shp-cli.o $(LIBLWGEOM) 
 	$(LIBTOOL) --mode=link \
-	  $(CC) $(CFLAGS) $^ $(ICONV_LDFLAGS) $(PGSQL_FE_LDFLAGS) $(GETTEXT_LDFLAGS) -o $@ 
+	  $(CC) $(CFLAGS) $^ $(ICONV_LDFLAGS) $(PGSQL_FE_LDFLAGS) $(GETTEXT_LDFLAGS) $(SFCGAL_LDFLAGS) -o $@ 
 
 $(SHP2PGSQL-CLI): $(SHPLIB_OBJS) shp2pgsql-core.o shp2pgsql-cli.o $(LIBLWGEOM) 
 	$(LIBTOOL) --mode=link \
-	  $(CC) $(CFLAGS) $^ -o $@ $(GETTEXT_LDFLAGS) $(ICONV_LDFLAGS) 
+	  $(CC) $(CFLAGS) $^ -o $@ $(GETTEXT_LDFLAGS) $(ICONV_LDFLAGS) $(SFCGAL_LDFLAGS)
 
 shp2pgsql-gui.o: shp2pgsql-gui.c shp2pgsql-core.h shpcommon.h
 	$(CC) $(CFLAGS) $(GTK_CFLAGS) $(PGSQL_FE_CPPFLAGS) -o $@ -c shp2pgsql-gui.c
diff -Naur postgis-svn/postgis/gserialized_typmod.c postgis-sfcgal/postgis/gserialized_typmod.c
--- postgis-svn/postgis/gserialized_typmod.c	2013-01-28 16:48:14.688627098 +0100
+++ postgis-sfcgal/postgis/gserialized_typmod.c	2013-01-28 16:49:01.792628218 +0100
@@ -329,6 +329,7 @@
 PG_FUNCTION_INFO_V1(geometry_enforce_typmod);
 Datum geometry_enforce_typmod(PG_FUNCTION_ARGS)
 {
+	lwnotice("geometry_enforce_typmod, %p", PG_GETARG_POINTER(0) );
 	GSERIALIZED *arg = (GSERIALIZED*)PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
 	int32 typmod = PG_GETARG_INT32(1);
 	/* We don't need to have different behavior based on explicitness. */
diff -Naur postgis-svn/postgis/lwgeom_geos.c postgis-sfcgal/postgis/lwgeom_geos.c
--- postgis-svn/postgis/lwgeom_geos.c	2013-01-28 16:48:14.684627098 +0100
+++ postgis-sfcgal/postgis/lwgeom_geos.c	2013-01-28 16:49:01.796628218 +0100
@@ -2538,7 +2538,6 @@
 	PG_RETURN_BOOL(result);
 }
 
-
 PG_FUNCTION_INFO_V1(intersects);
 Datum intersects(PG_FUNCTION_ARGS)
 {
@@ -2699,7 +2698,7 @@
 
 	PG_RETURN_BOOL(result);
 }
-
+//#endif
 
 PG_FUNCTION_INFO_V1(touches);
 Datum touches(PG_FUNCTION_ARGS)
diff -Naur postgis-svn/postgis/lwgeom_sfcgal.cpp postgis-sfcgal/postgis/lwgeom_sfcgal.cpp
--- postgis-svn/postgis/lwgeom_sfcgal.cpp	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/lwgeom_sfcgal.cpp	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,259 @@
+/**********************************************************************
+ *
+ * PostGIS - Spatial Types for PostgreSQL
+ * http://postgis.refractions.net
+ *
+ * Wrapper around SFCGAL for 3D and exact geometries
+ *
+ * Copyright 2012-2013 Oslandia <contact@oslandia.com>
+ *
+ * This is free software; you can redistribute and/or modify it under
+ * the terms of the GNU General Public Licence. See the COPYING file.
+ *
+ **********************************************************************/
+
+#include <stdexcept>
+#include <vector>
+#include <string>
+#include <iostream>
+#include <fstream>
+
+#include <SFCGAL/Geometry.h>
+#include <SFCGAL/PreparedGeometry.h>
+#include <SFCGAL/TriangulatedSurface.h>
+#include <SFCGAL/Solid.h>
+#include <SFCGAL/tools/Log.h>
+#include <SFCGAL/algorithm/triangulate.h>
+#include <SFCGAL/algorithm/intersects.h>
+#include <SFCGAL/algorithm/covers.h>
+#include <SFCGAL/algorithm/intersection.h>
+#include <SFCGAL/algorithm/convexHull.h>
+#include <SFCGAL/algorithm/area.h>
+#include <SFCGAL/algorithm/extrude.h>
+#include <SFCGAL/algorithm/distance.h>
+#include <SFCGAL/algorithm/distance3d.h>
+#include <SFCGAL/algorithm/plane.h>
+#include <SFCGAL/transform/ForceZOrderPoints.h>
+#include <SFCGAL/algorithm/collectionExtract.h>
+#include <SFCGAL/io/wkt.h>
+#include <SFCGAL/io/ewkt.h>
+#include <SFCGAL/io/Serialization.h>
+
+/* TODO: we probaby don't need _all_ these pgsql headers */
+extern "C" {
+#include "postgres.h"
+#include "fmgr.h"
+#include "miscadmin.h"
+#include "utils/array.h"
+#include "utils/builtins.h"
+#include "utils/hsearch.h"
+#include "utils/memutils.h"
+#include "executor/spi.h"
+#include "funcapi.h"
+
+#include "../postgis_config.h"
+#include "lwgeom_functions_analytic.h" /* for point_in_polygon */
+#include "lwgeom_cache.h"
+#include "liblwgeom_internal.h"
+#include "lwgeom_rtree.h"
+
+}
+
+#include "lwgeom_sfcgal.h"
+#include "lwgeom_sfcgal_wrapper.h"
+
+/**
+ * Conversion from GSERIALIZED* to SFCGAL::PreparedGeometry
+ */
+std::auto_ptr<SFCGAL::PreparedGeometry> POSTGIS2SFCGALp(GSERIALIZED *pglwgeom)
+{
+	LWGEOM *lwgeom = lwgeom_from_gserialized(pglwgeom);
+	if ( ! lwgeom )
+	{
+		throw std::runtime_error("POSTGIS2SFCGALp: unable to deserialize input");
+	}
+	std::auto_ptr<SFCGAL::PreparedGeometry> g(new SFCGAL::PreparedGeometry(LWGEOM2SFCGAL(lwgeom), gserialized_get_srid(pglwgeom)) );
+	lwgeom_free(lwgeom);
+	return g;
+}
+
+
+/**
+ * Conversion from GSERIALIZED* to SFCGAL::Geometry
+ */
+std::auto_ptr<SFCGAL::Geometry> POSTGIS2SFCGAL(GSERIALIZED *pglwgeom)
+{
+	LWGEOM *lwgeom = lwgeom_from_gserialized(pglwgeom);
+	if ( ! lwgeom )
+	{
+		throw std::runtime_error("POSTGIS2SFCGAL: unable to deserialize input");
+	}
+	std::auto_ptr<SFCGAL::Geometry> g(LWGEOM2SFCGAL(lwgeom));
+	lwgeom_free(lwgeom);
+	return g;
+}
+
+/**
+ * Conversion from SFCGAL::Geometry to GSERIALIZED*
+ */
+GSERIALIZED* SFCGAL2POSTGIS(const SFCGAL::Geometry& geom, bool force3D, int SRID )
+{
+	LWGEOM* lwgeom = SFCGAL2LWGEOM( &geom, force3D, SRID );
+	if ( lwgeom_needs_bbox(lwgeom) == LW_TRUE )
+	{
+		lwgeom_add_bbox(lwgeom);
+	}
+
+	GSERIALIZED* result = geometry_serialize(lwgeom);
+	lwgeom_free(lwgeom);
+
+	return result;
+}
+
+/**
+ * Conversion from SFCGAL::PreparedGeometry to GSERIALIZED*
+ */
+GSERIALIZED* SFCGAL2POSTGIS( const SFCGAL::PreparedGeometry& geom, bool force3D )
+{
+	return SFCGAL2POSTGIS( geom.geometry(), force3D, geom.SRID() );
+}
+
+/**
+ * Conversion from WKT to GSERIALIZED
+ */
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_from_text);
+}
+extern "C" Datum sfcgal_from_text(PG_FUNCTION_ARGS)
+{
+	GSERIALIZED* result;
+	text *wkttext = PG_GETARG_TEXT_P(0);
+	char *cstring = text2cstring(wkttext);
+
+	std::auto_ptr<SFCGAL::PreparedGeometry> g;
+	try
+	{
+		g = SFCGAL::io::readEwkt( cstring, strlen(cstring) );
+	}
+	catch ( std::exception& e )
+	{
+		lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+		return 0;
+	}
+	result = SFCGAL2POSTGIS( *g, false );
+	PG_RETURN_POINTER(result);
+}
+
+/**
+ *
+ * Macros needed for arguments of type SFCGAL::Geometry
+ *
+ */
+
+// Type index, unique for each type
+// How to extract a ith argument of type Geometry
+#define SFCGAL_TYPE_Geometry_WRAPPER_INPUT( i )				\
+	GSERIALIZED* BOOST_PP_CAT(input, i);				\
+	BOOST_PP_CAT(input,i) = (GSERIALIZED*)PG_DETOAST_DATUM(PG_GETARG_DATUM(i)); \
+	std::auto_ptr<SFCGAL::Geometry> BOOST_PP_CAT(geom,i);		\
+	try								\
+	{								\
+		BOOST_PP_CAT( geom, i ) = POSTGIS2SFCGAL( BOOST_PP_CAT( input, i ) ); \
+	}								\
+	catch ( std::exception& e ) {					\
+		lwerror( "Argument geometry could not be converted to SFCGAL: %s", e.what() ); \
+		PG_RETURN_NULL();					\
+	}
+// Use dereference for std::auto_ptr<Geometry>
+#define SFCGAL_TYPE_Geometry_WRAPPER_ACCESS_INPUT( i )  \
+	* BOOST_PP_CAT( geom, i )
+
+#define SFCGAL_TYPE_Geometry_WRAPPER_CONVERT_RESULT()			\
+	GSERIALIZED* gresult;						\
+	if ( result.get() ) {						\
+		try {							\
+			gresult = SFCGAL2POSTGIS( *result, result->is3D(), gserialized_get_srid(input0) ); \
+		}							\
+		catch ( std::exception& e ) {				\
+			lwerror("Result geometry could not be converted to lwgeom: %s", e.what() ); \
+			PG_RETURN_NULL();				\
+		}							\
+	}
+
+#define SFCGAL_TYPE_Geometry_WRAPPER_RETURN()	\
+	PG_RETURN_POINTER( gresult )
+
+#define SFCGAL_TYPE_Geometry_WRAPPER_TO_CSTR( i )	\
+	"%s", BOOST_PP_CAT( geom, i )->asText().c_str()
+
+#define SFCGAL_TYPE_Geometry_WRAPPER_FREE_INPUT( i )	\
+	PG_FREE_IF_COPY( BOOST_PP_CAT( input, i ), i )
+
+#define SFCGAL_TYPE_Geometry_WRAPPER_DECLARE_RETURN_VAR()	\
+	std::auto_ptr<SFCGAL::Geometry> result
+
+SFCGAL_WRAPPER_DECLARE_FUNCTION( intersects, SFCGAL::algorithm::intersects, bool, (Geometry)(Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( intersects3D, SFCGAL::algorithm::intersects3D, bool, (Geometry)(Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( intersection, SFCGAL::algorithm::intersection, Geometry, (Geometry)(Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( intersection3D, SFCGAL::algorithm::intersection3D, Geometry, (Geometry)(Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( convexhull, SFCGAL::algorithm::convexHull, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( convexhull3D, SFCGAL::algorithm::convexHull3D, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( area, SFCGAL::algorithm::area, double, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( area3D, SFCGAL::algorithm::area3D, double, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( hasplane, _sfcgal_hasplane, bool, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( pointing_up, _sfcgal_pointing_up, bool, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( triangulate, _sfcgal_triangulate, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( triangulate2D, _sfcgal_triangulate2D, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( extrude, _sfcgal_extrude, Geometry, (Geometry)(double)(double)(double) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( make_solid, _sfcgal_make_solid, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( force_z_up, _sfcgal_force_z_up, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( distance, SFCGAL::algorithm::distance, double, (Geometry)(Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( distance3D, SFCGAL::algorithm::distance3D, double, (Geometry)(Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( copy, _sfcgal_copy, Geometry, (Geometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( buffer, _sfcgal_buffer2D, Geometry, (Geometry)(double)(int) )
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_collection_extract);
+}
+
+extern "C" Datum sfcgal_collection_extract(PG_FUNCTION_ARGS)
+{
+    // transform a polyhedral surface into a solid with only one exterior shell
+    GSERIALIZED *geom1;
+    
+    GSERIALIZED *result;
+    
+    geom1 = (GSERIALIZED *)PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
+    uint32_t extractType = PG_GETARG_INT32(1);
+
+    std::auto_ptr<SFCGAL::Geometry> g1;
+    try {
+	g1 = POSTGIS2SFCGAL( geom1 );
+    }
+    catch ( std::exception& e ) {
+	lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+	PG_RETURN_NULL();
+    }
+    if ( extractType != 3 ) {
+	    lwerror( "collectionExtract is only supported for polygons(3)");
+	    PG_RETURN_NULL();
+    }
+
+    try
+    {
+	    std::auto_ptr<SFCGAL::Geometry> gresult = SFCGAL::algorithm::collectionExtractPolygons( g1 );
+	    result = SFCGAL2POSTGIS( *gresult, /* force3D */ true, gserialized_get_srid( geom1 ) );
+    }
+    catch ( std::exception& e ) {
+	lwnotice("geom1: %s", g1->asText().c_str());
+	lwnotice(e.what());
+	lwerror("Error during execution of collectionExtract()");
+	PG_RETURN_NULL();
+    }
+    
+    PG_FREE_IF_COPY(geom1, 0);
+    
+    PG_RETURN_POINTER(result);
+}
+
+
diff -Naur postgis-svn/postgis/lwgeom_sfcgal_exactgeom.cpp postgis-sfcgal/postgis/lwgeom_sfcgal_exactgeom.cpp
--- postgis-svn/postgis/lwgeom_sfcgal_exactgeom.cpp	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/lwgeom_sfcgal_exactgeom.cpp	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,229 @@
+/**********************************************************************
+ *
+ * PostGIS - Spatial Types for PostgreSQL
+ * http://postgis.refractions.net
+ *
+ * Wrapper around SFCGAL for 3D and exact geometries
+ *
+ * Copyright 2012-2013 Oslandia <contact@oslandia.com>
+ *
+ * This is free software; you can redistribute and/or modify it under
+ * the terms of the GNU General Public Licence. See the COPYING file.
+ *
+ **********************************************************************/
+
+#include "lwgeom_sfcgal_wrapper.h"
+
+#include <SFCGAL/Geometry.h>
+#include <SFCGAL/TriangulatedSurface.h>
+#include <SFCGAL/Solid.h>
+#include <SFCGAL/algorithm/triangulate.h>
+#include <SFCGAL/algorithm/extrude.h>
+#include <SFCGAL/algorithm/intersects.h>
+#include <SFCGAL/algorithm/intersection.h>
+#include <SFCGAL/algorithm/convexHull.h>
+#include <SFCGAL/algorithm/distance.h>
+#include <SFCGAL/algorithm/distance3d.h>
+#include <SFCGAL/algorithm/area.h>
+#include <SFCGAL/algorithm/plane.h>
+#include <SFCGAL/transform/ForceZOrderPoints.h>
+#include <SFCGAL/io/wkt.h>
+#include <SFCGAL/io/ewkt.h>
+#include <SFCGAL/io/Serialization.h>
+
+extern "C" {
+#include "postgres.h"
+#include "fmgr.h"
+#include "utils/memutils.h"
+
+#include "../postgis_config.h"
+#include "lwgeom_pg.h"
+}
+
+/**
+ * ExactGeometry varlen structure
+ *
+ * An exact geometry is a serialized representation of a SFCGAL::Geometry that
+ * keeps the arbitrary precision of numbers
+ */
+struct ExactGeometry
+{
+	uint32_t size;
+	char data[1];
+};
+
+/**
+ * Convert a SFCGAL::Geometry to its binary serialization
+ */
+ExactGeometry* serializeExactGeometry( const SFCGAL::PreparedGeometry& g1 )
+{
+    std::string raw = SFCGAL::io::writeBinaryPrepared( g1 );
+    ExactGeometry* g = (ExactGeometry*)palloc( raw.size() + 1 + 4 );
+    memmove( &g->data[0], raw.data(), raw.size() );
+    SET_VARSIZE( g, raw.size() );
+    return g;
+}
+
+/**
+ * Convert a binary serialization of a SFCGAL::Geometry to an instanciation
+ */
+std::auto_ptr<SFCGAL::PreparedGeometry> unserializeExactGeometry( ExactGeometry* ptr )
+{
+    uint32_t s = VARSIZE( ptr );
+    std::string gstr( &ptr->data[0], s );
+    return SFCGAL::io::readBinaryPrepared( gstr );	
+}
+
+/**
+ * Text (WKT) representation of an exact geometry
+ */
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_exact_out);
+}
+
+extern "C" Datum sfcgal_exact_out(PG_FUNCTION_ARGS)
+{
+    ExactGeometry *geom1;
+    
+    geom1 = (ExactGeometry *)PG_GETARG_DATUM(0);
+
+    std::auto_ptr<SFCGAL::PreparedGeometry> g = unserializeExactGeometry( geom1 );
+
+    std::string wkt = g->asEWKT( /* exact */ -1 );
+    char * retstr = (char*)palloc( wkt.size() + 1 );
+    strncpy( retstr, wkt.c_str(), wkt.size() + 1 );
+
+    PG_RETURN_CSTRING( retstr );
+}
+
+/**
+ * Conversion from a text representation (WKT) to an exact geometry
+ */
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_exact_in);
+	PG_FUNCTION_INFO_V1(sfcgal_exact_from_text);
+}
+
+ExactGeometry* exactFromCString( char* cstring )
+{
+	std::auto_ptr<SFCGAL::PreparedGeometry> g;
+	try
+	{
+		g = SFCGAL::io::readEwkt( cstring, strlen(cstring) );
+	}
+	catch ( std::exception& e )
+	{
+		lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+		return 0;
+	}
+
+	ExactGeometry* exactG = serializeExactGeometry( *g );
+	return exactG;
+}
+
+extern "C" Datum sfcgal_exact_in(PG_FUNCTION_ARGS)
+{
+	char* cstring = PG_GETARG_CSTRING( 0 );
+	ExactGeometry* e =  exactFromCString( cstring );
+	if (!e)
+		PG_RETURN_NULL();
+	PG_RETURN_POINTER( e );
+}
+
+extern "C" Datum sfcgal_exact_from_text(PG_FUNCTION_ARGS)
+{
+	text *wkttext = PG_GETARG_TEXT_P(0);
+	char *wkt = text2cstring(wkttext);
+	ExactGeometry* e = exactFromCString( wkt );
+	if (!e)
+		PG_RETURN_NULL();
+	PG_RETURN_POINTER( e );
+}
+
+/**
+ * Conversion from a regular PostGIS geometry to an exact geometry
+ */
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_exact_from_geom);
+}
+
+extern "C" Datum sfcgal_exact_from_geom(PG_FUNCTION_ARGS)
+{
+    GSERIALIZED *geom1;
+    
+    geom1 = (GSERIALIZED *)PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
+
+    std::auto_ptr<SFCGAL::PreparedGeometry> g1;
+    try {
+	g1 = POSTGIS2SFCGALp( geom1 );
+    }
+    catch ( std::exception& e ) {
+	lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+	PG_RETURN_NULL();
+    }
+
+    ExactGeometry* exactG = serializeExactGeometry( *g1 );
+    PG_RETURN_POINTER( exactG );
+}
+
+
+/**
+ * Conversion from an exact geometry to a regular PostGIS geometry
+ */
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_geom_from_exact);
+}
+
+extern "C" Datum sfcgal_geom_from_exact(PG_FUNCTION_ARGS)
+{
+    ExactGeometry *geom1 = (ExactGeometry *)PG_GETARG_DATUM(0);
+    std::auto_ptr<SFCGAL::PreparedGeometry> g = unserializeExactGeometry( geom1 );
+
+    GSERIALIZED* result = SFCGAL2POSTGIS( *g, false );
+    PG_RETURN_POINTER( result );
+}
+
+/**
+ *
+ * Macros for exact geometry argument wrapping
+ *
+ */
+
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_INPUT( i ) \
+	std::auto_ptr<SFCGAL::PreparedGeometry> BOOST_PP_CAT( input, i )  = unserializeExactGeometry( (ExactGeometry*)PG_DETOAST_DATUM(PG_GETARG_DATUM(i)) );
+
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_ACCESS_INPUT( i )  \
+	BOOST_PP_CAT( input, i )->geometry()
+
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_FREE_INPUT( i )  /* */
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_CONVERT_RESULT()   /* */
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_DECLARE_RETURN_VAR() \
+	std::auto_ptr<SFCGAL::Geometry> result
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_RETURN() \
+	SFCGAL::PreparedGeometry pgeom( result, input0->SRID() ); \
+	PG_RETURN_POINTER( serializeExactGeometry( pgeom ) );
+
+#define SFCGAL_TYPE_exactGeometry_WRAPPER_TO_CSTR( i )   			\
+	"%s", BOOST_PP_CAT( input, i ) ->asEWKT().c_str()
+
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_intersects, SFCGAL::algorithm::intersects, bool, (exactGeometry)(exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_intersects3D, SFCGAL::algorithm::intersects3D, bool, (exactGeometry)(exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_intersection, SFCGAL::algorithm::intersection, exactGeometry, (exactGeometry)(exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_intersection3D, SFCGAL::algorithm::intersection3D, exactGeometry, (exactGeometry)(exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_convexhull, SFCGAL::algorithm::convexHull, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_convexhull3D, SFCGAL::algorithm::convexHull3D, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_area, SFCGAL::algorithm::area, double, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_area3D, SFCGAL::algorithm::area3D, double, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_hasplane, _sfcgal_hasplane, bool, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_pointing_up, _sfcgal_pointing_up, bool, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_triangulate, _sfcgal_triangulate, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_triangulate2D, _sfcgal_triangulate2D, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_extrude, _sfcgal_extrude, exactGeometry, (exactGeometry)(double)(double)(double) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_make_solid, _sfcgal_make_solid, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_force_z_up, _sfcgal_force_z_up, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_distance, SFCGAL::algorithm::distance, double, (exactGeometry)(exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_distance3D, SFCGAL::algorithm::distance3D, double, (exactGeometry)(exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_copy, _sfcgal_copy, exactGeometry, (exactGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( exact_buffer, _sfcgal_buffer2D, exactGeometry, (exactGeometry)(double)(int) )
diff -Naur postgis-svn/postgis/lwgeom_sfcgal.h postgis-sfcgal/postgis/lwgeom_sfcgal.h
--- postgis-svn/postgis/lwgeom_sfcgal.h	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/lwgeom_sfcgal.h	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,7 @@
+#ifndef LWGEOM_SFCGAL_H_
+#define LWGEOM_SFCGAL_H_ 1
+
+#include "../liblwgeom/lwgeom_sfcgal.h" /* for GEOSGeom */
+#include "liblwgeom.h" /* for GSERIALIZED */
+
+#endif /* LWGEOM_GEOS_H_ 1 */
diff -Naur postgis-svn/postgis/lwgeom_sfcgal_refgeom.cpp postgis-sfcgal/postgis/lwgeom_sfcgal_refgeom.cpp
--- postgis-svn/postgis/lwgeom_sfcgal_refgeom.cpp	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/lwgeom_sfcgal_refgeom.cpp	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,422 @@
+/**********************************************************************
+ *
+ * PostGIS - Spatial Types for PostgreSQL
+ * http://postgis.refractions.net
+ *
+ * Wrapper around SFCGAL for 3D and exact geometries
+ *
+ * Copyright 2012-2013 Oslandia <contact@oslandia.com>
+ *
+ * This is free software; you can redistribute and/or modify it under
+ * the terms of the GNU General Public Licence. See the COPYING file.
+ *
+ **********************************************************************/
+
+#include "lwgeom_sfcgal_wrapper.h"
+
+#include <vector>
+#include <map>
+
+#include <SFCGAL/Geometry.h>
+#include <SFCGAL/PreparedGeometry.h>
+#include <SFCGAL/TriangulatedSurface.h>
+#include <SFCGAL/Solid.h>
+#include <SFCGAL/algorithm/triangulate.h>
+#include <SFCGAL/algorithm/extrude.h>
+#include <SFCGAL/algorithm/intersects.h>
+#include <SFCGAL/algorithm/intersection.h>
+#include <SFCGAL/algorithm/convexHull.h>
+#include <SFCGAL/algorithm/distance.h>
+#include <SFCGAL/algorithm/distance3d.h>
+#include <SFCGAL/algorithm/area.h>
+#include <SFCGAL/algorithm/plane.h>
+#include <SFCGAL/transform/ForceZOrderPoints.h>
+#include <SFCGAL/io/wkt.h>
+#include <SFCGAL/io/ewkt.h>
+#include <SFCGAL/io/Serialization.h>
+
+extern "C" {
+#include "postgres.h"
+#include "fmgr.h"
+#include "utils/memutils.h"
+#include "nodes/execnodes.h"
+
+#include "../postgis_config.h"
+#include "lwgeom_pg.h"
+}
+
+/**
+ * Only used for debugging purpose
+ */
+static void display_children( MemoryContext context, int level, MemoryContext current )
+{
+	char indent[level*2+1];
+	memset( indent, ' ', level*2 );
+	indent[level*2] = 0;
+
+	if ( context == current && level > 0 ) {
+		indent[0] = '>';
+	}
+	
+	lwnotice( "%s%s %p", indent, context->name, context );
+
+	MemoryContext child = context->firstchild;
+	while ( child != 0 ) {
+		display_children( child, level + 2, current );
+		child = child->nextchild;
+	}
+}
+
+/**
+ * Only used for debugging purpose
+ */
+static void display_contexts( MemoryContext refContext )
+{
+	MemoryContext c = refContext;
+	while ( c != TopMemoryContext ) {
+		c = c->parent;
+	}
+
+	display_children( c, 0, refContext );
+}
+
+/**
+ * Global pool of referenced geometries.
+ *
+ * A list of pointers to geometry can be associated to a MemoryContext
+ * They are deleted when the MemoryContext is deleted or reset
+ */
+class GeometryPool
+{
+public:
+	static void init( MemoryContext context )
+	{
+	}
+
+	static bool isEmpty( MemoryContext context )
+	{
+		/* mandatory implementation */
+		return false;
+	}
+
+	static void check( MemoryContext context )
+	{
+	}
+
+	static void stats( MemoryContext context, int level )
+	{
+		fprintf(stderr, "%s: Ref geometry context\n", context->name);
+	}
+
+	/**
+	 * Is the given Geometry still existing ?
+	 */
+	static bool isReferenced( SFCGAL::PreparedGeometry* geometry )
+	{
+		// this has to be fast, the geometry is then the key of the pool_ map
+		return pool_.find( geometry ) != pool_.end();
+	}
+
+	/**
+	 * Save a reference to the given Geometry.
+	 * It is associated with a MemoryContext with a proper life cycle.
+	 */
+	static void reference( SFCGAL::PreparedGeometry* geometry )
+	{
+		//
+		// Find the memory context used to store SFCGAL::Geometry*
+		// Ideally, this would be in the closest parent context of the current function evaluation.
+		//
+		// If the current context is a not descendant of a PortalMemory, it means this context is volatile and will be
+		// reset between calls within the same tuple access. In this case, attach our context to the MessageContext
+		// else, use the current context
+		MemoryContext parentContext = MessageContext;
+		
+		MemoryContext c = CurrentMemoryContext;
+		while ( c != TopMemoryContext ) {
+			// If it's a child of a Portal[Heap]Memory
+			if ( !strncmp( c->name, "Portal", 6 ) ) {
+				parentContext = CurrentMemoryContext;
+				break;
+			}
+			c = c->parent;
+		}
+		
+		MemoryContext childContext = 0;
+		// If a child context already exists, use it
+		ChildContextMap::const_iterator child_it = childContext_.find( parentContext );
+		if ( child_it != childContext_.end() ) {
+			childContext = child_it->second;
+		}
+		else {
+			// Else, create a new one.
+			// We won't allocate anything in the new context. It is only used for its destruction callbacks.
+			// It is thus allocated with the minimum required size
+			char contextName[] = "SFCGAL";
+			childContext = MemoryContextCreate( T_AllocSetContext, sizeof(MemoryContextData) + strlen(contextName) + 1,
+							    &GeometryPool::contextMethods,
+							    parentContext,
+							    contextName );
+
+			// associate this new context to its parent
+			childContext_[ parentContext ] = childContext;
+		}
+		
+		// force next reset. When the parent will be reset, reset will be called on this child
+		childContext->isReset = false;
+		
+		// now reference the geometry
+		pool_[ geometry ] = childContext;
+	}
+	
+	static void deleteContext( MemoryContext context )
+	{
+		for ( GeometryReference::iterator it = pool_.begin(); it != pool_.end(); ++it ) {
+			if ( it->second == context ) {
+				delete it->first;
+				pool_.erase( it );
+			}
+		}
+
+		// delete the ChildContextMap part
+		for ( ChildContextMap::iterator it = childContext_.begin(); it != childContext_.end(); ++it ) {
+			if ( it->second == context ) {
+				childContext_.erase( it );
+				break;
+			}
+		}
+	}
+
+	static MemoryContextMethods contextMethods;
+private:
+	typedef std::map<SFCGAL::PreparedGeometry*, MemoryContext> GeometryReference;
+	static GeometryReference pool_;
+
+	// memory context => child memory context
+	typedef std::map<MemoryContext, MemoryContext> ChildContextMap;
+	static ChildContextMap childContext_;
+};
+GeometryPool::GeometryReference GeometryPool::pool_;
+GeometryPool::ChildContextMap GeometryPool::childContext_;
+
+MemoryContextMethods GeometryPool::contextMethods = {
+	NULL, // alloc
+	NULL, // free
+	NULL, // realloc
+	GeometryPool::init,
+	GeometryPool::deleteContext, // reset
+	GeometryPool::deleteContext,
+	NULL, // get_chunk_space
+	GeometryPool::isEmpty,
+	GeometryPool::stats
+#ifdef MEMORY_CONTEXT_CHECKING
+	, GeometryPool::check
+#endif
+};
+
+/**
+ * Get a Geometry pointer from function arguments
+ */
+static SFCGAL::PreparedGeometry* get_geometry_arg( FunctionCallInfo fcinfo, size_t n )
+{
+	void** p = (void**)PG_GETARG_POINTER( n );
+	SFCGAL::PreparedGeometry* pp = (SFCGAL::PreparedGeometry*)(*p);
+	if ( ! GeometryPool::isReferenced( pp ) ) {
+		// The geometry has been deleted
+		return 0;
+	}
+	return pp;
+}
+
+/**
+ * Get a Geometry pointer from function arguments, returns error if the geometry does not exist anymore
+ */
+static SFCGAL::PreparedGeometry* get_geometry_arg_secure( FunctionCallInfo fcinfo, size_t n )
+{
+	void** p = (void**)PG_GETARG_POINTER( n );
+	SFCGAL::PreparedGeometry* pp = (SFCGAL::PreparedGeometry*)(*p);
+	if ( ! GeometryPool::isReferenced( pp ) ) {
+		lwerror( "Unable to access deleted geometry !" );
+		return 0;
+	}
+	return pp;
+}
+
+/**
+ * Prepare a Geometry for return
+ */
+Datum prepare_for_return( SFCGAL::PreparedGeometry* geo )
+{
+	GeometryPool::reference( geo );
+
+	// allocate space for a pointer
+	void** p = (void**)palloc( sizeof(void*) );
+	*p = (void *)geo;
+	return Datum(p);
+}
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_ref_in);
+	PG_FUNCTION_INFO_V1(sfcgal_ref_from_text);
+}
+
+/**
+ * Convert a WKT to a referenced geometry
+ */
+extern "C" Datum sfcgal_ref_in(PG_FUNCTION_ARGS)
+{
+	char* cstring = PG_GETARG_CSTRING( 0 );
+
+	std::auto_ptr<SFCGAL::PreparedGeometry> g;
+	try
+	{
+		g = SFCGAL::io::readEwkt( cstring, strlen(cstring) );
+	}
+	catch ( std::exception& e )
+	{
+		lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+		PG_RETURN_NULL();
+	}
+
+	return prepare_for_return( g.release() );
+}
+
+/**
+ * Convert a WKT to a referenced geometry
+ */
+extern "C" Datum sfcgal_ref_from_text(PG_FUNCTION_ARGS)
+{
+	//	display_contexts( CurrentMemoryContext );
+	text *wkttext = PG_GETARG_TEXT_P(0);
+	char *cstring = text2cstring(wkttext);
+
+	std::auto_ptr<SFCGAL::PreparedGeometry> g;
+	try
+	{
+		g = SFCGAL::io::readEwkt( cstring, strlen(cstring) );
+	}
+	catch ( std::exception& e )
+	{
+		lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+		PG_RETURN_NULL();
+	}
+
+	return prepare_for_return( g.release() );
+}
+
+/**
+ * Convert a referenced geometry to its WKT representation
+ */
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_ref_out);
+}
+
+extern "C" Datum sfcgal_ref_out(PG_FUNCTION_ARGS)
+{
+	SFCGAL::PreparedGeometry* g = get_geometry_arg( fcinfo, 0 );
+	if ( !g ) {
+		char deleted[] = "-deleted-";
+		char* retstr = (char*)palloc( strlen(deleted) + 1 );
+		strncpy( retstr, deleted, strlen(deleted) + 1 );
+
+		lwnotice( "Referenced geometries must not be stored" );
+		PG_RETURN_CSTRING( retstr );
+	}
+
+	std::string wkt = g->asEWKT( /* exact */ -1 );
+	char * retstr = (char*)palloc( wkt.size() + 1 );
+	strncpy( retstr, wkt.c_str(), wkt.size() + 1 );
+	
+	PG_RETURN_CSTRING( retstr );
+}
+
+/**
+ * Conversion from a regular PostGIS geometry to a ref geometry
+ */
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_ref_from_geom);
+}
+
+extern "C" Datum sfcgal_ref_from_geom(PG_FUNCTION_ARGS)
+{
+	GSERIALIZED *geom1;
+	
+	geom1 = (GSERIALIZED *)PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
+	
+	std::auto_ptr<SFCGAL::PreparedGeometry> g1;
+	try {
+		g1 = POSTGIS2SFCGALp( geom1 );
+	}
+	catch ( std::exception& e ) {
+		lwerror("First argument geometry could not be converted to SFCGAL: %s", e.what() );
+		PG_RETURN_NULL();
+	}
+	
+	return prepare_for_return( g1.release() );
+}
+
+
+/**
+ * Conversion from a ref geometry to a regular PostGIS geometry
+ */
+
+extern "C" {
+	PG_FUNCTION_INFO_V1(sfcgal_geom_from_ref);
+}
+
+extern "C" Datum sfcgal_geom_from_ref(PG_FUNCTION_ARGS)
+{
+	SFCGAL::PreparedGeometry* g = get_geometry_arg_secure( fcinfo, 0 );
+	if ( !g ) {
+		PG_RETURN_NULL();
+	}
+	GSERIALIZED* result = SFCGAL2POSTGIS( *g, false );
+	PG_RETURN_POINTER( result );
+}
+
+/**
+ *
+ * Macros for ref geometry argument wrapping
+ *
+ */
+#define SFCGAL_TYPE_refGeometry_WRAPPER_INPUT( i )			\
+	SFCGAL::PreparedGeometry* BOOST_PP_CAT( input, i ) = get_geometry_arg_secure( fcinfo, i ); \
+	if ( ! BOOST_PP_CAT( input, i ) ) {				\
+		PG_RETURN_NULL();					\
+	}
+
+#define SFCGAL_TYPE_refGeometry_WRAPPER_ACCESS_INPUT( i )	\
+	BOOST_PP_CAT( input, i )->geometry()
+
+#define SFCGAL_TYPE_refGeometry_WRAPPER_FREE_INPUT( i )  /* */
+#define SFCGAL_TYPE_refGeometry_WRAPPER_DECLARE_RETURN_VAR() std::auto_ptr<SFCGAL::Geometry> result
+#define SFCGAL_TYPE_refGeometry_WRAPPER_CONVERT_RESULT()   /* */
+#define SFCGAL_TYPE_refGeometry_WRAPPER_RETURN()			\
+	SFCGAL::PreparedGeometry* geo = new SFCGAL::PreparedGeometry( result, input0->SRID() ); \
+	return prepare_for_return( geo );
+
+#define SFCGAL_TYPE_refGeometry_WRAPPER_TO_CSTR( i )		\
+	"%s", BOOST_PP_CAT( input, i ) ->asEWKT().c_str()
+
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_intersects, SFCGAL::algorithm::intersects, bool, (refGeometry)(refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_intersects3D, SFCGAL::algorithm::intersects3D, bool, (refGeometry)(refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_intersection, SFCGAL::algorithm::intersection, refGeometry, (refGeometry)(refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_intersection3D, SFCGAL::algorithm::intersection3D, refGeometry, (refGeometry)(refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_convexhull, SFCGAL::algorithm::convexHull, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_convexhull3D, SFCGAL::algorithm::convexHull3D, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_area, SFCGAL::algorithm::area, double, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_area3D, SFCGAL::algorithm::area3D, double, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_hasplane, _sfcgal_hasplane, bool, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_pointing_up, _sfcgal_pointing_up, bool, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_triangulate, _sfcgal_triangulate, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_triangulate2D, _sfcgal_triangulate2D, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_extrude, _sfcgal_extrude, refGeometry, (refGeometry)(double)(double)(double) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_make_solid, _sfcgal_make_solid, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_force_z_up, _sfcgal_force_z_up, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_distance, SFCGAL::algorithm::distance, double, (refGeometry)(refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_distance3D, SFCGAL::algorithm::distance3D, double, (refGeometry)(refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_copy, _sfcgal_copy, refGeometry, (refGeometry) )
+SFCGAL_WRAPPER_DECLARE_FUNCTION( ref_buffer, _sfcgal_buffer2D, refGeometry, (refGeometry)(double)(int) )
+
diff -Naur postgis-svn/postgis/lwgeom_sfcgal_wrapper.cpp postgis-sfcgal/postgis/lwgeom_sfcgal_wrapper.cpp
--- postgis-svn/postgis/lwgeom_sfcgal_wrapper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/lwgeom_sfcgal_wrapper.cpp	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,132 @@
+/**********************************************************************
+ *
+ * PostGIS - Spatial Types for PostgreSQL
+ * http://postgis.refractions.net
+ *
+ * Wrapper around SFCGAL for 3D and exact geometries
+ *
+ * Copyright 2012-2013 Oslandia <oslandia@oslandia.com>
+ *
+ * This is free software; you can redistribute and/or modify it under
+ * the terms of the GNU General Public Licence. See the COPYING file.
+ *
+ **********************************************************************/
+
+#include <boost/format.hpp>
+
+#include <SFCGAL/Geometry.h>
+#include <SFCGAL/Point.h>
+#include <SFCGAL/LineString.h>
+#include <SFCGAL/Polygon.h>
+#include <SFCGAL/TriangulatedSurface.h>
+#include <SFCGAL/MultiPolygon.h>
+#include <SFCGAL/Solid.h>
+#include <SFCGAL/algorithm/triangulate.h>
+#include <SFCGAL/algorithm/extrude.h>
+#include <SFCGAL/algorithm/intersects.h>
+#include <SFCGAL/algorithm/intersection.h>
+#include <SFCGAL/algorithm/plane.h>
+#include <SFCGAL/transform/ForceZOrderPoints.h>
+#include <SFCGAL/algorithm/minkowskiSum.h>
+
+#include "lwgeom_sfcgal_wrapper.h"
+
+bool _sfcgal_hasplane( const SFCGAL::Geometry& g )
+{
+	if ( g.geometryTypeId() != SFCGAL::TYPE_POLYGON )
+	{
+		std::string msg = (boost::format("hasPlane() cannot be applied to a geometry of type %1") % g.geometryType() ).str();
+		throw std::runtime_error( msg.c_str() );
+	}
+	return SFCGAL::algorithm::hasPlane3D< CGAL::Exact_predicates_exact_constructions_kernel >( g.as< const SFCGAL::Polygon >() );
+}
+
+bool _sfcgal_pointing_up( const SFCGAL::Geometry& g )
+{
+	if ( g.geometryTypeId() != SFCGAL::TYPE_POLYGON )
+	{
+		std::string msg = (boost::format("pointing_up() cannot be applied to a geometry of type %1") % g.geometryType() ).str();
+		throw std::runtime_error( msg.c_str() );
+	}
+	return g.as<SFCGAL::Polygon>().isCounterClockWiseOriented();
+}
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_triangulate( const SFCGAL::Geometry& g )
+{
+	SFCGAL::TriangulatedSurface* surf = new SFCGAL::TriangulatedSurface;
+	SFCGAL::algorithm::triangulate( g, *surf );
+	return std::auto_ptr<SFCGAL::Geometry>( surf );
+}
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_triangulate2D( const SFCGAL::Geometry& g )
+{
+	SFCGAL::TriangulatedSurface* surf = new SFCGAL::TriangulatedSurface;
+	SFCGAL::algorithm::triangulate2D( g, *surf );
+	return std::auto_ptr<SFCGAL::Geometry>( surf );
+}
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_extrude( SFCGAL::Geometry& g, double dx, double dy, double dz )
+{
+	SFCGAL::transform::ForceZOrderPoints forceZ;
+	g.accept( forceZ );
+	return SFCGAL::algorithm::extrude( g, dx, dy, dz );
+}
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_make_solid( const SFCGAL::Geometry& g )
+{
+    if ( g.geometryTypeId() == SFCGAL::TYPE_SOLID )
+    {
+	    // already a solid, return
+	    return std::auto_ptr<SFCGAL::Geometry>( g.clone() );
+    }
+    if ( g.geometryTypeId() != SFCGAL::TYPE_POLYHEDRALSURFACE )
+    {
+	    throw std::runtime_error( "make_solid only applies to polyhedral surfaces" );
+    }
+    return std::auto_ptr<SFCGAL::Geometry>( new SFCGAL::Solid( static_cast<const SFCGAL::PolyhedralSurface&>( g ) ) );
+}
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_force_z_up( SFCGAL::Geometry& g )
+{
+	    SFCGAL::transform::ForceZOrderPoints forceZ;
+	    g.accept( forceZ );
+	    return std::auto_ptr<SFCGAL::Geometry>( g.clone() );
+}
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_copy( SFCGAL::Geometry& g )
+{
+	    return std::auto_ptr<SFCGAL::Geometry>( g.clone() );
+}
+
+///
+///
+/// ST_buffer
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_buffer2D( SFCGAL::Geometry& g, double radius, int nSegQuarter )
+{
+	using namespace SFCGAL;
+
+	//
+	// build a circle approximation
+	int nPoints = nSegQuarter * 4;
+
+	LineString* ls = new LineString;
+	ls->addPoint( new Point( 0, radius ) );
+	for ( int i = 1; i < nPoints; ++i ) {
+		double x = radius * sin( i * 2 * M_PI / nPoints );
+		double y = radius * cos( i * 2 * M_PI / nPoints );
+
+		int32_t k = 1<<24;
+		// reduce precision of x and y
+		x = double(int32_t(x * k)) / k;
+		y = double(int32_t(y * k)) / k;
+		ls->addPoint( new Point( x, y ) );
+	}
+	ls->addPoint( new Point( 0, radius ) );
+	std::auto_ptr<Polygon> poly(new Polygon( ls ));
+
+	std::auto_ptr<MultiPolygon> sum = algorithm::minkowskiSum( g, *poly );
+	if ( sum->numGeometries() == 1 ) {
+		return std::auto_ptr<Geometry>( sum->geometryN(0).clone() );
+	}
+	return std::auto_ptr<Geometry>(sum);
+}
diff -Naur postgis-svn/postgis/lwgeom_sfcgal_wrapper.h postgis-sfcgal/postgis/lwgeom_sfcgal_wrapper.h
--- postgis-svn/postgis/lwgeom_sfcgal_wrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/lwgeom_sfcgal_wrapper.h	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,155 @@
+#ifndef LWGEOM_SFCGAL_WRAPPER_H
+#define LWGEOM_SFCGAL_WRAPPER_H
+
+#include "lwgeom_sfcgal.h"
+
+#include <boost/preprocessor.hpp>
+
+#include <SFCGAL/Geometry.h>
+#include <SFCGAL/PreparedGeometry.h>
+
+/**
+ *
+ * Set of preprocessing macros used to declare PostGIS functions that call SFCGAL methods
+ *
+ * Each argument type must have the associated macros declared.
+ * Please refer to the definition of SFCGAL_WRAPPER_DECLARE_FUNCTION if you want to add a new type.
+ */
+
+/**
+ * generic bool argument wrapper
+ */
+#define SFCGAL_TYPE_bool_WRAPPER_INPUT( i )                  /* not used */
+#define SFCGAL_TYPE_bool_WRAPPER_ACCESS_INPUT( i )           /* not used */
+#define SFCGAL_TYPE_bool_WRAPPER_TO_CSTR( i )                "%d", BOOST_PP_CAT( input, i ) ? 1 : 0
+#define SFCGAL_TYPE_bool_WRAPPER_DECLARE_RETURN_VAR()        bool result
+#define SFCGAL_TYPE_bool_WRAPPER_CONVERT_RESULT()            /**/
+#define SFCGAL_TYPE_bool_WRAPPER_FREE_INPUT( i )             /**/
+#define SFCGAL_TYPE_bool_WRAPPER_RETURN()                    PG_RETURN_BOOL( result )
+
+/**
+ * generic int argument wrapper
+ */
+#define SFCGAL_TYPE_int_WRAPPER_INPUT( i )                int32_t BOOST_PP_CAT(input, i) = PG_GETARG_INT32(i);
+#define SFCGAL_TYPE_int_WRAPPER_ACCESS_INPUT( i )         BOOST_PP_CAT( input, i )
+#define SFCGAL_TYPE_int_WRAPPER_TO_CSTR( i )              "%ld", BOOST_PP_CAT( input, i )
+#define SFCGAL_TYPE_int_WRAPPER_DECLARE_RETURN_VAR()      int32_t result
+#define SFCGAL_TYPE_int_WRAPPER_CONVERT_RESULT()          /**/
+#define SFCGAL_TYPE_int_WRAPPER_FREE_INPUT( i )           /**/
+#define SFCGAL_TYPE_int_WRAPPER_RETURN()                  PG_RETURN_INT32( result )
+
+/**
+ * generic double argument wrapper
+ */
+#define SFCGAL_TYPE_double_WRAPPER_INPUT( i )                double BOOST_PP_CAT(input, i) = PG_GETARG_FLOAT8(i);
+#define SFCGAL_TYPE_double_WRAPPER_ACCESS_INPUT( i )         BOOST_PP_CAT( input, i )
+#define SFCGAL_TYPE_double_WRAPPER_TO_CSTR( i )              "%g", BOOST_PP_CAT( input, i )
+#define SFCGAL_TYPE_double_WRAPPER_DECLARE_RETURN_VAR()      double result
+#define SFCGAL_TYPE_double_WRAPPER_CONVERT_RESULT()          /**/
+#define SFCGAL_TYPE_double_WRAPPER_FREE_INPUT( i )           /**/
+#define SFCGAL_TYPE_double_WRAPPER_RETURN()                  PG_RETURN_FLOAT8( result )
+
+/**
+ *  auxiliary macros
+ */
+
+// Returns SFCGAL_TYPE_type_WRAPPERname
+// name must start with '_'
+#define _SFCGAL_WR_type_expansion( type, name )              BOOST_PP_CAT( BOOST_PP_CAT( BOOST_PP_CAT( SFCGAL_TYPE_, type ), _WRAPPER), name )
+
+#define _SFCGAL_WR_dereference_arg( type, i )	             _SFCGAL_WR_type_expansion( type, _ACCESS_INPUT )( i )
+#define _SFCGAL_WR_insert_comma( i, msize )                  BOOST_PP_COMMA_IF( BOOST_PP_LESS( i, BOOST_PP_DEC(msize) ) )
+
+#define _SFCGAL_WR_dereference_arg_m( r, seqsize, i, elem )  _SFCGAL_WR_dereference_arg( elem, i ) _SFCGAL_WR_insert_comma( i, seqsize )
+// build a call list of input arguments
+#define _SFCGAL_WR_dereference_list( types )	             BOOST_PP_SEQ_FOR_EACH_I( _SFCGAL_WR_dereference_arg_m, BOOST_PP_SEQ_SIZE(types), types )
+
+#define _SFCGAL_WR_declare_input_param( r, data, i, type )   _SFCGAL_WR_type_expansion( type, _INPUT )( i )
+#define _SFCGAL_WR_to_c_str( type, i )                       _SFCGAL_WR_type_expansion( type, _TO_CSTR)( i )
+#define _SFCGAL_WR_declare_return_var( type )                _SFCGAL_WR_type_expansion( type, _DECLARE_RETURN_VAR)()
+#define _SFCGAL_WR_lwnotice( r, data, i, type )              lwnotice( BOOST_PP_STRINGIZE( BOOST_PP_CAT( input, i ) ) ": " _SFCGAL_WR_to_c_str( type, i ) );
+#define _SFCGAL_WR_notices( types )                          BOOST_PP_SEQ_FOR_EACH_I( _SFCGAL_WR_lwnotice, _, types )
+
+#define _SFCGAL_WR_free_input( r, data, i, type )            _SFCGAL_WR_type_expansion( type, _FREE_INPUT)( i );
+#define _SFCGAL_WR_free_inputs( types )                      BOOST_PP_SEQ_FOR_EACH_I( _SFCGAL_WR_free_input, _, types )
+
+/**
+ * This is the core of the substitution macro that is used to declare wrapping functions.
+ *
+ * fname: name of the C function that will be exposed as part of the PostGIS API (prefixed with 'sfcgal_')
+ * function: SFCGAL C++ function
+ * return_type: return type of the SFCGAL function
+ * types: BOOST_PP sequence of argument types
+ *
+ * Example : SFCGAL_WRAPPER_DECLARE_FUNCTION( intersects, SFCGAL::algorithm::intersects, bool, (Geometry)(Geometry) )
+ *
+ * This will declare a function sfcgal_intersects that takes two geometries in argument and returns a bool.
+ * Type names refer to the name used in SFCGAL_TYPE_xxx_WRAPPER_yyy() macros
+ */
+#define SFCGAL_WRAPPER_DECLARE_FUNCTION( fname, function, return_type, types ) \
+	extern "C" { PG_FUNCTION_INFO_V1( BOOST_PP_CAT( sfcgal_, fname ) ); } \
+	extern "C" Datum BOOST_PP_CAT( sfcgal_, fname )( PG_FUNCTION_ARGS ) \
+	{								\
+		BOOST_PP_SEQ_FOR_EACH_I( _SFCGAL_WR_declare_input_param, _, types ); \
+		_SFCGAL_WR_declare_return_var( return_type );		\
+		try {							\
+			result = function( _SFCGAL_WR_dereference_list( types ) ); \
+		}							\
+		catch ( std::exception& e )				\
+		{							\
+			_SFCGAL_WR_notices( types );			\
+			lwnotice( e.what() );				\
+			lwerror( "Error during execution of sfcgal_" BOOST_PP_STRINGIZE(fname) ); \
+			PG_RETURN_NULL();				\
+		}							\
+		_SFCGAL_WR_type_expansion( return_type, _CONVERT_RESULT )(); \
+		_SFCGAL_WR_free_inputs( types );			\
+		_SFCGAL_WR_type_expansion( return_type, _RETURN )();	\
+	}
+
+/**
+ * Conversion from a GSERIALIZED to a SFCGAL::Geometry
+ */
+std::auto_ptr<SFCGAL::Geometry> POSTGIS2SFCGAL(GSERIALIZED *pglwgeom);
+
+/**
+ * Conversion from a GSERIALIZED to a SFCGAL::PreparedGeometry
+ */
+std::auto_ptr<SFCGAL::PreparedGeometry> POSTGIS2SFCGALp(GSERIALIZED *pglwgeom);
+
+/**
+ * Conversion from a SFCGAL::Geometry to a GSERIALIZED
+ */
+GSERIALIZED* SFCGAL2POSTGIS(const SFCGAL::Geometry& geom, bool force3D, int SRID );
+
+/**
+ * Conversion from a SFCGAL::PreparedGeometry to a GSERIALIZED
+ */
+GSERIALIZED* SFCGAL2POSTGIS( const SFCGAL::PreparedGeometry& geom, bool force3D );
+
+/**
+ * Wrappers around SFCGAL, when direct call is not possible
+ */
+bool _sfcgal_hasplane( const SFCGAL::Geometry& g );
+
+bool _sfcgal_pointing_up( const SFCGAL::Geometry& g );
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_triangulate( const SFCGAL::Geometry& g );
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_triangulate2D( const SFCGAL::Geometry& g );
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_extrude( SFCGAL::Geometry& g, double dx, double dy, double dz );
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_make_solid( const SFCGAL::Geometry& g );
+
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_force_z_up( SFCGAL::Geometry& g );
+
+//
+//
+// copy input to output, used for serialization tests
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_copy( SFCGAL::Geometry& g );
+
+//
+//
+std::auto_ptr<SFCGAL::Geometry> _sfcgal_buffer2D( SFCGAL::Geometry& g, double radius, int nSegQuarter );
+#endif
diff -Naur postgis-svn/postgis/Makefile.in postgis-sfcgal/postgis/Makefile.in
--- postgis-svn/postgis/Makefile.in	2013-01-28 16:48:14.684627098 +0100
+++ postgis-sfcgal/postgis/Makefile.in	2013-01-28 16:49:01.792628218 +0100
@@ -24,6 +24,15 @@
 # SQL objects (files requiring pre-processing)
 SQL_OBJS=postgis.sql.in legacy.sql.in legacy_minimal.sql.in 
 
+GEOM_BACKEND_OBJ = lwgeom_geos.o
+SFCGAL_BACKEND_OBJ = lwgeom_sfcgal.o lwgeom_sfcgal_wrapper.o lwgeom_sfcgal_refgeom.o lwgeom_sfcgal_exactgeom.o
+
+ifeq (@POSTGIS_SFCGAL@,1)
+BACKEND_OBJ=$(GEOM_BACKEND_OBJ) $(SFCGAL_BACKEND_OBJ)
+else
+BACKEND_OBJ=$(GEOM_BACKEND_OBJ)
+endif
+
 # PostgreSQL objects
 PG_OBJS= \
 	postgis_module.o \
@@ -36,7 +45,7 @@
 	lwgeom_btree.o \
 	lwgeom_box.o \
 	lwgeom_box3d.o \
-	lwgeom_geos.o \
+	$(BACKEND_OBJ) \
 	lwgeom_geos_prepared.o \
 	lwgeom_geos_clean.o \
 	lwgeom_geos_relatematch.o \
@@ -74,8 +83,13 @@
 # to an existing liblwgeom.so in the PostgreSQL $libdir supplied by an
 # older version of PostGIS, rather than with the static liblwgeom.a 
 # supplied with newer versions of PostGIS
-PG_CPPFLAGS += @CPPFLAGS@ -I../liblwgeom -I../libpgcommon
-SHLIB_LINK_F = ../libpgcommon/libpgcommon.a ../liblwgeom/.libs/liblwgeom.a @SHLIB_LINK@ 
+PG_CPPFLAGS += @CPPFLAGS@ -I../liblwgeom -I../libpgcommon -fPIC
+SHLIB_LINK_F = ../libpgcommon/libpgcommon.a ../liblwgeom/.libs/liblwgeom.a @SHLIB_LINK@
+
+ifeq (@POSTGIS_SFCGAL@,1)
+PG_CPPFLAGS += @SFCGAL_CPPFLAGS@
+SHLIB_LINK_F += @SFCGAL_LDFLAGS@
+endif
 
 # Extra files to remove during 'make clean'
 EXTRA_CLEAN=$(SQL_OBJS) legacy_uninstall.sql
@@ -151,7 +165,7 @@
 # SQL objects are also dependent on postgis_config.h for PostgreSQL version
 $(SQL_OBJS): ../postgis_config.h ../postgis_svn_revision.h
 
-postgis.sql.in: sqldefines.h long_xact.sql.in.c geography.sql.in.c 
+postgis.sql.in: sqldefines.h long_xact.sql.in.c geography.sql.in.c postgis_sfcgal.sql.in.c
 
 #uninstall_postgis.sql.in: sqldefines.h uninstall_sqlmm.sql.in.c uninstall_long_xact.sql.in.c uninstall_geography.sql.in.c
 uninstall_postgis.sql: postgis.sql ../utils/create_undef.pl 
diff -Naur postgis-svn/postgis/postgis_sfcgal.sql.in.c postgis-sfcgal/postgis/postgis_sfcgal.sql.in.c
--- postgis-svn/postgis/postgis_sfcgal.sql.in.c	1970-01-01 01:00:00.000000000 +0100
+++ postgis-sfcgal/postgis/postgis_sfcgal.sql.in.c	2013-01-28 16:49:01.796628218 +0100
@@ -0,0 +1,394 @@
+---------------------------------------------------------------------------
+--
+-- PostGIS - Exact geometry types for PostgreSQL
+-- Copyright 2012-2013 Oslandia <contact@oslandia.com>
+--
+-- This is free software; you can redistribute and/or modify it under
+-- the terms of the GNU General Public Licence. See the COPYING file.
+--
+---------------------------------------------------------------------------
+
+-----------------------------------------------------------------------
+--
+-- SFCGAL schema
+--
+-----------------------------------------------------------------------
+
+DROP SCHEMA IF EXISTS sfcgal CASCADE;
+CREATE SCHEMA sfcgal;
+
+CREATE FUNCTION sfcgal.ST_GeomFromText(text)
+    RETURNS geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_from_text'
+    LANGUAGE C IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_MakeSolid(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_make_solid'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal._ST_Intersects(geom1 geometry, geom2 geometry)
+	RETURNS boolean
+	AS 'MODULE_PATHNAME','sfcgal_intersects'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DIntersects(geom1 geometry, geom2 geometry)
+	RETURNS boolean
+	AS 'MODULE_PATHNAME','sfcgal_intersects3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Intersection(geom1 geometry, geom2 geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_intersection'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DIntersection(geom1 geometry, geom2 geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_intersection3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_ConvexHull(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_convexhull'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DConvexHull(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_convexhull3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_DelaunayTriangles(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_triangulate2D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DDelaunayTriangles(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_triangulate'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Area(geometry)
+	RETURNS FLOAT8
+	AS 'MODULE_PATHNAME','sfcgal_area'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DArea(geometry)
+	RETURNS FLOAT8
+	AS 'MODULE_PATHNAME','sfcgal_area3D'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_HasPlane(geometry)
+	RETURNS BOOL
+	AS 'MODULE_PATHNAME','sfcgal_hasplane'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Extrude(geometry, float8, float8, float8)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_extrude'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_ForceZUp(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_force_z_up'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_PointingUp(geometry)
+	RETURNS BOOL
+	AS 'MODULE_PATHNAME','sfcgal_pointing_up'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_CollectionExtract(geometry, int4)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_collection_extract'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Copy(geometry)
+	RETURNS geometry
+	AS 'MODULE_PATHNAME','sfcgal_copy'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Buffer(geometry, float8, int4)
+        RETURNS geometry
+        AS 'MODULE_PATHNAME','sfcgal_buffer'
+        LANGUAGE 'c' IMMUTABLE STRICT;
+
+-----------------------------------------------------------------------
+--
+-- SFCGAL Referenced exact geometries
+--
+-----------------------------------------------------------------------
+
+CREATE TYPE ref_geometry;
+
+-- convert a wkt to a ref_geometry
+CREATE FUNCTION sfcgal.ref_in(cstring)
+    RETURNS ref_geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_ref_in'
+    LANGUAGE C IMMUTABLE STRICT;
+
+-- display a ref_geometry
+CREATE FUNCTION sfcgal.ref_out(ref_geometry)
+    RETURNS cstring
+    AS 'MODULE_PATHNAME', 'sfcgal_ref_out'
+    LANGUAGE C IMMUTABLE STRICT;
+
+CREATE TYPE ref_geometry (
+    internallength = 8,
+    input = sfcgal.ref_in,
+    output = sfcgal.ref_out
+);
+
+-- geometry to ref_geometry
+CREATE FUNCTION sfcgal.ST_RefGeometry( geometry )
+    RETURNS ref_geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_ref_from_geom'
+    LANGUAGE C IMMUTABLE STRICT;
+
+-- exact_geometry to geometry
+CREATE FUNCTION sfcgal.ST_Geometry( ref_geometry )
+    RETURNS geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_geom_from_ref'
+    LANGUAGE C IMMUTABLE STRICT;
+
+CREATE FUNCTION sfcgal.ST_RefGeomFromText(text)
+    RETURNS ref_geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_ref_from_text'
+    LANGUAGE C IMMUTABLE STRICT;
+
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_MakeSolid(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_make_solid'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Intersects(geom1 ref_geometry, geom2 ref_geometry)
+	RETURNS boolean
+	AS 'MODULE_PATHNAME','sfcgal_ref_intersects'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DIntersects(geom1 ref_geometry, geom2 ref_geometry)
+	RETURNS boolean
+	AS 'MODULE_PATHNAME','sfcgal_ref_intersects3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Intersection(geom1 ref_geometry, geom2 ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_intersection'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DIntersection(geom1 ref_geometry, geom2 ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_intersection3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_ConvexHull(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_convexhull'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DConvexHull(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_convexhull3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_DelaunayTriangles(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_triangulate2D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DDelaunayTriangles(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_triangulate'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Area(ref_geometry)
+	RETURNS FLOAT8
+	AS 'MODULE_PATHNAME','sfcgal_ref_area'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DArea(ref_geometry)
+	RETURNS FLOAT8
+	AS 'MODULE_PATHNAME','sfcgal_ref_area3D'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_HasPlane(ref_geometry)
+	RETURNS BOOL
+	AS 'MODULE_PATHNAME','sfcgal_ref_hasplane'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Extrude(ref_geometry, float8, float8, float8)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_extrude'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_ForceZUp(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_force_z_up'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_PointingUp(ref_geometry)
+	RETURNS BOOL
+	AS 'MODULE_PATHNAME','sfcgal_ref_pointing_up'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Copy(ref_geometry)
+	RETURNS ref_geometry
+	AS 'MODULE_PATHNAME','sfcgal_ref_copy'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Buffer(ref_geometry, float8, int4)
+        RETURNS ref_geometry
+        AS 'MODULE_PATHNAME','sfcgal_ref_buffer'
+        LANGUAGE 'c' IMMUTABLE STRICT;
+
+-----------------------------------------------------------------------
+--
+-- SFCGAL Serialized exact geometries
+--
+-----------------------------------------------------------------------
+
+CREATE TYPE exact_geometry;
+
+-- convert a wkt to an exact geometry
+CREATE FUNCTION sfcgal.exact_in(cstring)
+    RETURNS exact_geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_exact_in'
+    LANGUAGE C IMMUTABLE STRICT;
+
+-- display an exact_geometry
+CREATE FUNCTION sfcgal.exact_out(exact_geometry)
+    RETURNS cstring
+    AS 'MODULE_PATHNAME', 'sfcgal_exact_out'
+    LANGUAGE C IMMUTABLE STRICT;
+
+CREATE TYPE exact_geometry (
+    internallength = VARIABLE,
+    input = sfcgal.exact_in,
+    output = sfcgal.exact_out
+);
+
+-- geometry to exact_geometry
+CREATE FUNCTION sfcgal.ST_ExactGeometry( geometry )
+    RETURNS exact_geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_exact_from_geom'
+    LANGUAGE C IMMUTABLE STRICT;
+
+-- exact_geometry to geometry
+CREATE FUNCTION sfcgal.ST_Geometry( exact_geometry )
+    RETURNS geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_geom_from_exact'
+    LANGUAGE C IMMUTABLE STRICT;
+
+CREATE FUNCTION sfcgal.ST_ExactGeomFromText(text)
+    RETURNS exact_geometry
+    AS 'MODULE_PATHNAME', 'sfcgal_exact_from_text'
+    LANGUAGE C IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_MakeSolid(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_make_solid'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Intersects(geom1 exact_geometry, geom2 exact_geometry)
+	RETURNS boolean
+	AS 'MODULE_PATHNAME','sfcgal_exact_intersects'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DIntersects(geom1 exact_geometry, geom2 exact_geometry)
+	RETURNS boolean
+	AS 'MODULE_PATHNAME','sfcgal_exact_intersects3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Intersection(geom1 exact_geometry, geom2 exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_intersection'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DIntersection(geom1 exact_geometry, geom2 exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_intersection3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_ConvexHull(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_convexhull'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DConvexHull(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_convexhull3D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_DelaunayTriangles(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_triangulate2D'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DDelaunayTriangles(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_triangulate'
+	LANGUAGE 'c' IMMUTABLE STRICT
+	COST 100;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Area(exact_geometry)
+	RETURNS FLOAT8
+	AS 'MODULE_PATHNAME','sfcgal_exact_area'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_3DArea(exact_geometry)
+	RETURNS FLOAT8
+	AS 'MODULE_PATHNAME','sfcgal_exact_area3D'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_HasPlane(exact_geometry)
+	RETURNS BOOL
+	AS 'MODULE_PATHNAME','sfcgal_exact_hasplane'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Extrude(exact_geometry, float8, float8, float8)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_extrude'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_ForceZUp(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_force_z_up'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_PointingUp(exact_geometry)
+	RETURNS BOOL
+	AS 'MODULE_PATHNAME','sfcgal_exact_pointing_up'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Copy(exact_geometry)
+	RETURNS exact_geometry
+	AS 'MODULE_PATHNAME','sfcgal_exact_copy'
+	LANGUAGE 'c' IMMUTABLE STRICT;
+
+CREATE OR REPLACE FUNCTION sfcgal.ST_Buffer(exact_geometry, float8, int4)
+        RETURNS exact_geometry
+        AS 'MODULE_PATHNAME','sfcgal_exact_buffer'
+        LANGUAGE 'c' IMMUTABLE STRICT;
diff -Naur postgis-svn/postgis/postgis.sql.in.c postgis-sfcgal/postgis/postgis.sql.in.c
--- postgis-svn/postgis/postgis.sql.in.c	2013-01-28 16:48:14.704627098 +0100
+++ postgis-sfcgal/postgis/postgis.sql.in.c	2013-01-28 16:49:01.796628218 +0100
@@ -5132,4 +5132,9 @@
 GRANT SELECT ON TABLE geography_columns TO public;
 GRANT SELECT ON TABLE geometry_columns TO public;
 GRANT SELECT ON TABLE spatial_ref_sys TO public;
+
+#ifdef POSTGIS_SFCGAL
+#include "postgis_sfcgal.sql.in.c"
+#endif
+
 COMMIT;
diff -Naur postgis-svn/postgis/sqldefines.h.in postgis-sfcgal/postgis/sqldefines.h.in
--- postgis-svn/postgis/sqldefines.h.in	2013-01-28 16:48:14.692627098 +0100
+++ postgis-sfcgal/postgis/sqldefines.h.in	2013-01-28 16:49:01.796628218 +0100
@@ -28,6 +28,10 @@
 
 #define SRID_USR_MAX @SRID_USR_MAX@
 
+#if @POSTGIS_SFCGAL@
+#define POSTGIS_SFCGAL
+#endif
+
 #endif /* _LWPGIS_DEFINES */
 
 
